\documentclass[11pt]{article}


\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{tikz-3dplot}
\usepackage{tikz-cd}
\usepackage{xcolor}
\usepackage{proof}
\usepackage {alltt}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{listings}
\usepackage[export]{adjustbox}
\usepackage{verbatim}
\tikzset
  {cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt},cross/.default={1pt}}


\usepackage{amsmath }
\usepackage{framed}
\usepackage{proof}
\usepackage{enumerate,xspace,stmaryrd}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{textcomp,xspace}
\usepackage[top=2cm, bottom=2.5cm, right=2.5cm, left=2.5cm]{geometry}\usepackage{latexsym}  %For plain TeX symbols, such as \Box used in \qed
\usepackage{euscript}  %%Euler Script font
\usepackage {mdframed}
\usepackage{ifpdf}
\usepackage {alltt}
\renewcommand{\ttdefault}{txtt}
\ifpdf
  \usepackage{epstopdf}
\fi 
\usepackage{etoolbox}
\BeforeBeginEnvironment{tabular}{\begin{center}\small}
\AfterEndEnvironment{tabular}{\end{center}}

\newcommand{\A}{{\ensuremath{\mathbb A}}\xspace}
\newcommand{\B}{{\ensuremath{\mathbb B}}\xspace}
\newcommand{\C}{{\ensuremath{\mathbb C}}\xspace}
\newcommand{\D}{{\ensuremath{\mathbb D}}\xspace}
\newcommand{\F}{{\ensuremath{\mathbb F}}\xspace}
\newcommand{\G}{{\ensuremath{\mathbb G}}\xspace}
\newcommand{\R}{{\ensuremath{\mathbb R}}\xspace}

\newcommand{\rst}[1]{\overline{#1}\,}
\newcommand{\Sets}{{\ensuremath{\sf Sets}}\xspace}
\newcommand{\Cat}{{\ensuremath{\sf Cat}}\xspace}

\input xy
\xyoption{all}
\xyoption{2cell}
\UseAllTwocells

\title{Abstract machine for MPL (AMPL)}

\bibliographystyle{plain}

%%%%%%%%% macros defined %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\X}{{\ensuremath{\mathbb X}}\xspace}
\newcommand{\Y}{{\ensuremath{\mathbb Y}}\xspace}
\newcommand{\Z}{{\ensuremath{\mathbb Z}}\xspace}

\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\newcommand{\lollipop}{\ensuremath{-\!\!\circ}}

\newcommand{\op}{\ensuremath{^{\textnormal{op}}}}
\renewcommand{\hat}{\widehat}
\renewcommand{\b}{\bullet}
\renewcommand{\c}{\circ}
\newcommand{\ox}{\otimes}         
\newcommand{\x}{\times}     
\newcommand{\fold}[1]{\ensuremath{\left\{\!\!\!\;\left| #1 \right|\!\!\!\;\right\} }}  
\newcommand{\unfold}[1]{\ensuremath{\left(\!\!\!\;\left| #1 \right|\!\!\!\;\right) }}  
\def\endproof{~\hfill$\Box$\vskip 10pt}

\newtheorem{theorem}{Theorem}[section]    
\newtheorem{corollary}[theorem]{Corollary}   
\newtheorem{lemma}[theorem]{Lemma}   
\newtheorem{remark}[theorem]{Remark}   
\newtheorem{example}[theorem]{Example}   
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\proof}{\noindent{\sc Proof:}\xspace}

\def\monus{\buildrel\textstyle.\over
    {\hbox{\vrule height.55ex width0pt
        \smash{\hbox{\mathsurround=0pt$-$}}}}}
\def\xybox#1#2{\save [].[#2]!C="xb#1"*[F.]\frm{}\restore}

\begin{document}

\maketitle
\section {Abstract Machine for MPL (AMPL)}
\tikzstyle{stage} = [rectangle,minimum width=2.8cm,rounded corners,
                     minimum height=1.8cm,text centered, draw=black]
\tikzstyle{arrow} = [very thick,->,>=stealth]
In the previous chapters the different stages of interpretation of MPL programs (listed in Figure in \ref {fig:CSAM}) have been described. In this chapter, the last stage of interpretation, namely running MPL programs on MPL's abstract machine (called AMPL) is discussed.
~~\\
\begin{figure}[h!]
\begin {center}
\begin{tikzpicture}[scale = 1.5,every node/.style={very thick},node distance=2cm]
 \node (LE) [stage] {{\sf \small Lexing}};
 \node (PA) [stage,right of=LE,xshift=2.2cm] {{\sf \small Parsing}};
 \node (TC) [stage,right of=PA,xshift=2.2cm,text width = 1.8cm] {{\sf \small Type Inferencing}};
 \node (CP) [stage,below of=TC,yshift=-2.2cm,text width = 1.8cm] 
            {{\sf \small Compiling Pattern Matching}};
 \node (LL) [stage,left of=CP,xshift=-2.2cm,text width = 1.8cm] 
            {{\sf \small Lambda Lifting}};
 \node (AM) [stage,left of=LL,xshift=-2.2cm,text width = 1.8cm,fill=gray!30] 
            {{\sf \small Running programs on AMPL}};
 \draw [arrow] (LE) -- (PA);
 \draw [arrow] (PA) -- (TC);
 \draw [arrow] (TC) -- (CP);
 \draw [arrow] (CP) -- (LL);
 \draw [arrow] (LL) -- (AM);
\end{tikzpicture}
\caption{Compilation Stages} \label{fig:CSAM}
\end{center}
\end{figure}
~~\\

\subsection {Introduction to Abstract Machines}
Abstract machines are useful conceptual tools when implementing a programming language because they omit the many details of real machines and thus bridge the gap between the programming language and the physical machine. An added advantage of abstract machines is the ease of porting the language to different platforms. An abstract machine one reduces the problem of porting the programming language to the problem of porting the abstract machine. This is an easy task as the abstract machines are simpler and smaller than the programming language itself. This strategy was used by the programming language Java which used the abstract machine {\bf Java Virutal Machine (JVM)}. Some famous examples of {\em abstract machines} are:
\begin{itemize} 
  \item Landin's SECD Machine was one of the first abstract machines for functional programming languages specifically designed to evaluate lambda calculus expressions {\bf by value}.
  \item Modern-SEC Machine is an improved and efficient version of the SECD machine.
  \item Cardelli's Functional Abstract Machine (FAM) is an extended and optimized SECD machine. It was used in the first native-code implementation of ML.
  \item Cousineau, Curien and Mauny's Categorial Abstract Machine (CAM). Its instructions correspond to the constructions of a {\em Cartesian Closed Category}: identity, composition, abstraction, application, pairing, and selection. It was the basis for the CAML programming language.
  \item Three Instruction Machine (TIM) is a simple abstract machine for evaluation of super-combinators.
  \item Spineless-Tagless G-Machine (STG-Machine) is the abstract machine for Haskell.
  \item Warren Abstract Machine (WAM) is the abstract machine for Prolog.
\end {itemize}

\subsection {Introduction to AMPL}
AMPL is an abstract machine which runs MPL programs. Just as MPL is separated into two levels, {\bf Sequential MPL} and {\bf Concurrent MPL}, so too can AMPL can be thought of as two machine levels:
\begin{itemize}
  \item {\bf Sequential AMPL (SAMPL)} which runs {\bf Sequential MPL code}
  \item {\bf Concurrent AMPL (CAMPL)} which runs {\bf Concurrent MPL code}
\end {itemize}
This conceptual separation means AMPL has a modular description and design. Thus, either of the AMPL components can be modified without disturbing the other.
\section {Sequential Abstract Machine for MPL (SAMPL)}
Sequential MPL code compiles to Sequential AMPL( SAMPL). SAMPL is inspired by modern-SEC machine. However, the modern-SEC machine doesn't have explicit commands to which data types and codata types can be compiled. SAMPL augments the basic modern-SEC machine with {\sf case} and {\sf constructor} commands to compile data types and  {\sf record} and {\sf destructor} commands to compile codata types. SAMPL also adds commands for basic functions like addition, multiplication, equality testing etc which are built-in to the language. The SAMPL commands are evaluated {\bf by-value} except for the {\sf record} and {\sf destructor}, the codata type commands, which are lazily evaluated.

\subsection {SAMPL Commands}
Table \ref {SeqCommTable} provides a list of SAMPL commands and a brief description of each command.
\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Instruction &Explanation \\ \hline
~ & ~\\
${\sf Store}$ &   pushes the top stack element into the environment \\
${\sf Access}(n)$    &   put $n^{\rm th}$ value in the environment onto the stack. \\ 
${\sf Ret} $     &       return the top stack value and jump to the continuation below \\ 
${\sf call}~\<{\tt code}\>$ & jump to the code \\
 ~ & ~ \\ \hline
\multicolumn{2}{|l|}{Built in instructions:} \\ \hline
~ & ~ \\ 
 ${\sf Const}_T(k)$       &    push the constant $k$ of basic type $T$ on the stack \\
${\sf Add}$ &             Pop two arguments from the top of the stack and add them \\ 
${\sf Mul}$ &             Pop two arguments from the top of the stack and mlutiply them \\ 
${\sf Leq}$  &            Pop two arguments from the top of the stack and compare them \\ ~ & etc. \\ 
~ & ~\\ \hline
\multicolumn{2}{|l|}{Data instructions:} \\ \hline
~ & ~ \\ 
 ${\sf Cons}(i,n)$       &    push the $i^{\rm th}$ constructor onto the stack with arguments \\
                                  & the top $n$ elements of the stack, ${\sf Cons}(i,s_1,...,s_n)$ . \\
 ${\sf Case}[c_1,...,c_n]$ &     when ${\sf Cons}(i,t_1,...,t_n)$  is on the stack remove it and \\
                                   & push $t_1, ...., t_n$ into the environment and evaluate $c_i$. \\ 
 ~ & ~ \\ \hline
 \multicolumn{2}{|l|}{Codata instructions:} \\ \hline
  ${\sf Rec}[c_1,...,c_n]$      &         create a record on the stack with current environment, \\
                                            & ${\sf rec}([c_1,...,c_n],e)$  \\
 ${\sf Dest}(i,n)$ &             destruct a record: choose the $i^{\rm th}$  function closure $(c_i,e)$  \\
                        &  and run $c_i$ in environment $e$ supplemented with the first $n$ values on the stack. \\
~ & ~ \\ \hline
\end{tabular}
\caption{Machine Transitions for the SAMPL}
\label{SeqCommTable}
\end{center}
\end{table}

\subsection {Compilation of Sequential MPL Code to SAMPL Commands}
Sequential MPL code is converted to a list of SAMPL commands which are then executed on the abstract machine described in Table \ref {AMPL:TranSeqTable}. Sequential MPL is translated to SAMPL Code. The translation scheme is described below: 
 \begin{eqnarray} 
  \llbracket {\sf record}~\{ {\sf D_i} ~x_{1_i},...,x_{n_i} \mapsto t_i \}_{i \in [1,m]~} \rrbracket_v & = & {\sf Rec}[\llbracket t_i \rrbracket_{x_1,...,x_{n_i},v} ~{\sf Ret}]_{i \in [1,m]~} \\
  \llbracket (D_i(x,t_1,...,t_n) \rrbracket_v & = & \llbracket t_n \rrbracket_v ... \llbracket t_1 \rrbracket_v ~\llbracket x \rrbracket_v {\sf Dest}(i,n) \\
  \llbracket {\sf Cons}_i(t_1,..,t_n) \rrbracket_v & = & \llbracket t_n \rrbracket_v ... \llbracket t_1 \rrbracket_v ~ {\sf Cons}(i,n) \\
  \llbracket {\sf case} ~ t~ \{ {\sf Cons_i} ~x_{1_i},...,x_{n_i} \mapsto t_i \}_{i \in [1,m]~} \rrbracket_v & = & \llbracket t \rrbracket_v {\sf Case} [\llbracket t_i \rrbracket_{x_1,...,x_{n_i},v} ~{\sf Ret}]_{i \in [1,m]~} \\
  \llbracket x \rrbracket_v & = & {\sf Access}(n) ~~~~\mbox{where $n={\sf index}~v~x$} \\
   \llbracket a~{\rm op}~b \rrbracket_v & = & \llbracket b \rrbracket_v ~ \llbracket a \rrbracket_v {\sf Op} \\
    \llbracket k\rrbracket_v & = & {\sf Const}_T(k) 
  \end{eqnarray}
${\llbracket ~\rrbracket}_v$ signifies the compilation of a {\em Core MPL's} sequential constructs to {\em SAMPL} commands in context of an {\em environment} $v$. The environment acts as a repository of variables used in a piece of code being compiled. It is used to replace a variable name with the relative position in the program body.
~~\\~~\\
A description of these compilation steps is:
~~\\~~\\
$(1)$ is the compilation scheme for the {\sf record} construct. {\sf D$_i$} is the $i^{th}$ destructor and {\sf t$_i$} is the corresponding term for that destructor.
~~\\~~\\
$(2)$ is the compilation scheme for a {\sf destructor} represented by $D_i$. The first argument of {\sf D$_i$} is the record to be destructed and the subsequent arguments are the arguments of {\sf D$_i$}. 
~~\\~~\\ 
$(3)$ is the compilation of a {\sf constructor} $Cons_i$. The terms {\sf t$_1,\ldots,$ t$_n$} which are the arguments of the constructors are recursively compiled and concatenated in the order opposite to which they occur. The constructor name is gotten rid in the compilation process and is instead represented by a pair, the constructor number and the number of arguments that the constructor takes.
~~\\~~\\
$(4)$ is the compilation of a {\sf case} construct. A few things worth noting in the compilation of {\sf case} constructs are as follows:
\begin {itemize}
\item The term {\sf t$_i$} corresponding to the {\sf Cons$_i$} is compiled in the context enhanced with the arguments of {\sf Cons$_i$}.
\item {\sf Ret (return)} should be the last command in the compiled code corresponding to any constructor {\sf Cons$_i$}.
\item Before the compilation of the {\sf Case} construct starts, it should be ensured that the constructors of the data type are arranged in the same order as they have been defined.
\end{itemize}
$(5)$ is the compilation of a {\sf variable x}. The variable is looked up in the context $v$. The depth of the variable in the context is the argument to the {\sf Access} command.
~~\\~~\\
$(6)$ is the compilation of infix functions. These functions are converted to their postfix forms with their arguments recursively compiled.


\subsection {Transition Table for SAMPL}

Once {\bf Sequential MPL} has been compiled to SAMPL code, the code can then be executed on the abstract machine. The {\em Code} is represented as a list of SAMPL commands. Two other structures namely the {\em Environment} and the {\em Stack} need to be introduced in order to show how the machine works. Both {\em Environment} and {\em Stack} are Last In First Out (LIFO) data structures. In our implementation of MPL, they have been implemented using Haskell lists. 
~~\\~~\\
The {\em Environment} keeps track of which variables are visible in the code at a given point and is thus a transient data structure: it changes as one traverses through the code. The {\em stack} acts as storage for the intermediate values and the final result during the execution of the code. 
~~\\~~\\ 
The state of SAMPL at any given time can be described as the triple of the compiled SAMPL {\em Code}, {\em Environment}, and {\em Stack} represented as $(C,E,S)$. Executing SAMPL code means starting with an initial state and changing states based on the transition table for SAMPL described in Table \ref {AMPL:TranSeqTable} until a final state has been reached. The final state contains the result of the computation. The selection of transition at any step of code execution is done by {\bf pattern matching} the machine state against the transition table. Thus, the given description of the SAMPL is easily implemented in Haksell using its pattern matching feature.
~~\\
The initial state of the machine is formed by putting the compiled code as the first argument of the triple and intialising the {\em Enviornment} and {\em Stack} as empty lists.
~~\\
\begin{center}
Initial State : $(C,~\lbrack~\rbrack,~\lbrack~\rbrack)$
\end{center}
~~\\
The final state is reached when the {\em Code} and the {\em Environment} is empty. The top of the {\em Stack} contains the output value.
~~\\ 
\begin{center}
Final State : $(\lbrack~\rbrack,~\lbrack~\rbrack,~S)$
\end{center}
~~\\~~\\
In Table \ref {AMPL:TranSeqTable}, {\sf clos(c,e)} denotes closure of {\em Code} $c$ with {\em Environment} $e$ and {\sf e(n)} is the $n^{\rm th}$-element of the environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[!h]
\begin{center}
    \begin{tabular}{|l|l|l||l|l|l|}
    \hline 
      \multicolumn{3}{|c||}{Before} 
     & \multicolumn{3}{c|}{After} \\ \hline    
   Code   & Env  & Stack      
                      &Code   & Env  & Stack     \\ \hline
         ${\sf Store};c$   &$ e$    & $v:s$          
                     & $c$           & $v:e$    & $s$     \\ \hline   
        ${\sf Access}(n);c$   &$ e$    & $s$          
                     & $c$           & $e$    & $e(n):s$     \\ \hline    
      ${\sf Call}(c):c'$         & $e$    & $s$  
                     & $c$          & $e$   & ${\sf clos}(c',e):s$        \\ \hline              
    ${\sf Ret}:c$         & $e$    & $v:{\sf clos}(c',e'):s$  
                     & $c'$          & $e'$   & $v:s$        \\ \hline \hline  
         ${\sf Cons}(i,n):c $ & $e$    & $v_1:...,v_n:s$      
                     & $c$           &$ e$    & ${\sf cons}(i,[v_1,..,v_n]):s$    \\ \hline      
          ${\sf Case}(c_1,...,c_n):c $ & $e$ & ${\sf Cons}(i,[v_1,...,v_n]):s$ 
                     & $c_i$ & $v_1:..:v_n:e$ & ${\sf clo}(c,e):s$ \\ \hline \hline
     ${\sf Rec}(c_1,..,c_n):c$      & $e$   & $s$         
                     & $c$           & $e$    & ${\sf rec}([c_1,...,c_n],e):s$    \\ \hline
     ${\sf Dest}(i,n):c$         & $e$    & ${\sf rec}([c_1,..,c_n],e'):v_n:..:v_1:s$ 
                     & $ c_i$          & $v_1:..:v_n:e'$  & ${\sf clo}(c,e):s$      \\ \hline \hline
     ${\sf Const}_T(k):c $ & $e$    & $s$      
                     & $c$           &$ e$    & ${\sf const}_T(k):s$    \\ \hline      
     ${\sf Add}:c$         & $e$    & $n:m:s$      
                     & $c $          & $e$    & $(n+m):s$    \\ \hline                  
     ${\sf Mul}:c$         & $e$    & $n:m:s$      
                     & $c $          & $e$    & $(n*m):s$    \\ \hline 
     ${\sf Leq}:c$         & $e$    & $n:m:s$      
                     & $c $          & $e$    & $(n \leq m):s$    \\ \hline  
   \end{tabular}
\caption{Machine Transitions for the SAMPL}
\label{AMPL:TranSeqTable}
\end{center}
\end{table}

\subsection {Example : Compiling And Executing Sequential MPL Programs}
Table \ref {AMPL:SEQMPLComp} provides an example of compiling Sequential MPL to SAMPL. The Sequential MPL code being compiled is a function $f1$ whose body {\bf destructs} a {\sf record} with a {\sf destructor} $App$. $App$ takes two arguments: a {\sf record} to destruct and a second argument. The second argument 2 is indirectly an argument to {\sf record} $App(y) := y + 1$ being destructed. The function $f1$ is equivalent to the lambda application $(\lambda x.x+1)~2$. The function $f1$ demonstrates MPL's technique of simulating higher-order functions using codata types.
~~\\~~\\
Second row of Table \ref {AMPL:SEQMPLComp} shows an example of the step by step compilation of function $f1$ to its corresponding SAMPL code. The compilation steps have been labelled to identify which rules have been used in any given step.
~~\\~~\\ 
Table \ref  {AMPL:ExecSeqTable} shows an example of the step by step execution of SAMPL commands. The code selected for execution is the SAMPL code generated for function $f1$ in Table \ref {AMPL:SEQMPLComp}. In Table \ref {AMPL:ExecSeqTable}, too keep the table readable, $c$ has been used for ${\sf CInt}~1;{\sf Access}~1; {\sf Add}; {\sf Ret}$ .
~~\\~~\\
Execution of the code starts with empty {\em Environment} and {\em Stack}. In the final step {\em Code list} and the {\em Environment} are empty and the result is obtained on top of the {\em Stack}.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|} \hline
{}\\ 
{\bf MPL Program corresponding to $(\mathbf{\lambda x.~x+1})~2$} \\~~\\
\hline\hline 
\begin{minipage}{3in}
\begin{alltt}


codata C -> Exp(A,B) = App :: A,C -> B 

fun f1  =
   ->  App( record(App(y) :=  y + 1),2)


\end{alltt}
\end {minipage} \\ 
\hline 
{}\\ 
{\bf Step wise compilation to SAMPL} \\~~\\
\hline\hline 
\begin{minipage}{6in}
{
  \begin{align*} 
& {\big\llbracket {\sf App}\big({\sf record}~({\sf App(y)}:=y+1,2)\big)\big\rrbracket}_{[~]} 
& ({\sf Dest.}~~rule) \\~~\\ 
& {
   {\big\llbracket2\big\rrbracket}_{[~]} ~~ \texttt{++} ~~
   {\big\llbracket {\sf record}~({\sf App(y)}:=y+1)\big\rrbracket}_{[~]}
   ~~\texttt{++}~~\big[ {\sf Dest~1~1}\big]
  } & ({\sf Const.}~~\&~~{\sf Rec}~~rule) \\~~\\ 
& {
   {\big[{\sf CInt~~2}\big]}~~\texttt{++}~~
   {{\sf Rec}\Big[\big\llbracket y+1 \big\rrbracket~~ \texttt{++}~~[{\sf Ret}]\Big]}
   ~~\texttt{++}~~\big[ {\sf Dest~1~1}\big]
  } & {\sf (Op~(Infix)}~~rule) \\~~\\ 
& {
   \big[{\sf CInt~~2}\big]~~\texttt{++}~~
   {{\sf Rec}\Big[{\big\llbracket 1 \big\rrbracket}_{[y]} ~~ \texttt{++}~~{\big\llbracket y \big\rrbracket}_{[y]}~~\texttt{++}~~[{\sf Add}]~~\texttt{++}~~[{\sf Ret}]\Big]}
   ~~\texttt{++}~~\big[ {\sf Dest~1~1}\big]
  } & ({\sf Const.}~~\&~~{\sf Var.}~~rule) \\~~\\   
& {
   \big[{\sf CInt~~2}\big]~~\texttt{++}~~
   {{\sf Rec}\Big[[{\sf CInt~~1}] ~~ \texttt{++}~~[{\sf Access~~1}]~~
   \texttt{++}~~[{\sf Add}]~~\texttt{++}~~[{\sf Ret}]\Big]}
   ~~\texttt{++}~~\big[ {\sf Dest~1~1}\big]
  } & {} \\~~\\ 
& {
   \Big[{\sf CInt~~2},{\sf Rec}\big[{\sf CInt~~1},{\sf Access~~1,{\sf Add},{\sf Ret}}\big],{\sf Dest~1~1}\Big]
  } & {(SAMPL~~code)}   
\end{align*}
}
\end {minipage}\\ 
\hline 
{}\\
{\bf Compiled SAMPL Code} \\~~\\
\hline\hline 
\begin{minipage}{3in}
\begin{alltt}



[
  CInt 2,
  Rec [
        CInt 1,
        Access 1,
        Add,
        Ret
      ],
  Dest 1 1
]



\end{alltt}
\end{minipage}

\tabularnewline
\hline
\end{tabular}
\caption{Example : Compilation of Sequential MPL to SAMPL}
\label{AMPL:SEQMPLComp}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{table}[!h]
  \begin{center}
    \begin{tabular}{|l|l|l|}
    \hline
   Code                          & Env                     & Stack                                                    \\ \hline
     ${\sf CInt}(2) ; {\sf Rec}[c];{\sf Dest}~1~1$      & $\varepsilon$   & $\varepsilon$                                    \\ \hline
    ${\sf Rec}[c];{\sf Dest}~1~1$             & $\varepsilon$  & ${\sf cint}~2:\varepsilon$  \\ \hline
     ${\sf Dest}~1 ~1$     & $\varepsilon$   & ${\sf rec}([c],\varepsilon): {\sf cint}~2:\varepsilon$ \\ \hline
     ${\sf CInt}~1; {\sf Access}~1; {\sf Add}; {\sf Ret}$ & ${\sf cint} 2:\varepsilon$ & ${\sf clo}(\varepsilon,\varepsilon):\varepsilon$                                   \\ \hline
     ${\sf Access}(1): {\sf Add}: {\sf Ret}$           & ${\sf cint} 2:\varepsilon$ & ${\sf cint}~1:{\sf clo}(\varepsilon,\varepsilon):\varepsilon$                                                        \\ \hline
    ${\sf Add}: {\sf Ret}$                  & ${\sf cint}~2:\varepsilon$ & ${\sf cint}~2:{\sf cint}~1:{\sf clo}(\varepsilon,\varepsilon):\varepsilon$                                                     \\ \hline
      ${\sf Ret}$                        & ${\sf cint}~2:\varepsilon$ & ${\sf cint}~3:{\sf Clo}(\varepsilon,\varepsilon):\varepsilon$                                                       \\ \hline
    $\varepsilon$                     & $\varepsilon$   & ${\sf cint}~3:\varepsilon$                                                        \\ \hline
    \end{tabular}
    \caption{Executing Code on SAMPL}
    \label{AMPL:ExecSeqTable}
    \end{center}
    \end{table}

\section {Concurrent Abstract Machine for MPL (CAMPL)}
Concurrent Abstract Machine for MPL (CAMPL) is the machine on which the Concurrent MPL code is run. Concurrent MPL code comprises of processes. The state of a process is represented as a four tuple of {\em Stack, Translation, Environment, and Code} $(S,t,E,C)$. {\em Stack, Environment and Code} are also used to represent the state of Sequential MPL programs and have the same meaning here. 
\begin{itemize}
  \item The {\em Stack} holds the intermediate value and the final result when executing a process.
  \item The {\em Translation} is an additonal structure used in describing the state of a {\em Concurrent MPL} program. This additonal structure is required because Concurrent MPL programs have channels, a feature that the sequential MPL programs lack. {\em Translation} acts as a map of the local channel names to global channel names. This is required because a channel connecting two processes may be named differently inside each process. Processes can then use the {\em translation} to determine which local channels refer to which gobal channels.

  \item The {\em Environment} is used to determine which variables are visible at a given point of the Concurrent program.
  \item The {\em Code} is the list of Concurrent AMPL commands corresponding to the MPL program.
\end{itemize}

\begin{center}
Initial State : $(~\lbrack~\rbrack,t,\lbrack~\rbrack,C)$
\end{center}
~~\\
The initial state of CAMPL is formed by loading the compiled code corresponding to Concurrent MPL program (processes) as the fourth argument of the tuple, the {\em Translation} of channels corresponding to a process as the second argument, and intialising the {\em Environment} and {\em Stack} which are the first and the third arguments respectively, as empty lists.
~~\\
\begin{center}
Final State : $(S,\lbrack~\rbrack,\lbrack~\rbrack,\lbrack~\rbrack)$
\end{center}
~~\\
The final state is reached when the {\em Code}, the {\em Environment} and the {\em Translation} is empty. The top of the stack contains the output of the code.
~~\\~~\\
CAMPL consists of two main components, the {\bf Channel Mananger}, $\cal C$ and the {\bf Process Manager}, $\cal P$.
\subsection {Channel Mananger}
The {\bf Channel Manager}, $\cal C$ is a set of pairs of channels and their queues. It is represented as  ${\cal C}\{ (\alpha,q' \mid q) \}$ which indicates that a channel $\alpha$ has the communication queue $q' \mid q$ associated with it. A communication queue has two parts $q'$, the output polarity queue and q, the input polarity queue. If a value $x$ is being put on a channel, it will be added to the front of the output queue, represented as $x:q'$. If a channel $\alpha$ is expecting a value $y$, then $y$ is put at the back of the input queue represented as $q:y$. It is the first element of the output queue and last element of the input queue (represented as $x$ and $y$ in the representation $(x:q' \mid q:y)$ which are the subject to communication actions described in section \ref {ChanManAct}. 
\subsection {Process Mananger}
The {\bf Process Manager} is a set of processes. It is represented as $\cal P$ $\{(S,t,E,C)\}$ signifying that it has selected one process that will be advanced by one execution step. The {\bf Process Manager} selects this process non-deterministically. In practise one may want to execute this non-deterministically selected process not just by one step but for mutliple steps, until it has a concurrent action, before interrupting it.

\subsection {Interaction between Process Manager and Channel Manager}
The interaction between the {\bf Process Manager} and the {\bf Channel Manager} can be understood with the help of some examples.
~~\\~~\\
Suppose there are two MPL processes connected by a channel such that the first process {\bf P1} puts a value on the channel and the second process {\bf P2} receives the value on the channel. Since MPL assumes no fixed order of execution of processes, the process receiving the value on the channel may be executed before the process putting the value on the channel. When process {\bf P2} is executed before {\bf P1}, the {\bf Channel Manager} suspends the process {\bf P2} and attaches it to one of the queues (say output queue) of the channel, ch. When process {\bf P1} is scheduled and executed, the value is obtained on the channel and put on its input queue. Once {\bf Channel Manager} sees the configuration where a suspended process is attached to one queue of the channel and a value is present on the other queue of the channel, it reactivates the suspended process and puts it in the set of active processes. The {\bf Process Manager} can then schedule this active process for execution.
~~\\~~\\ 
Here the interaction between the {\bf Process Manager} and {\bf Channel Manager} has been explained in terms of just the {\bf get-put} command pair. However, similar interaction between the two components of CAMPL takes places for {\bf split-fork}, {\bf hput-hcase} and {\bf close-halt} pairs.
\subsection {Concurrent Commands}
In order to understand the working of CAMPL, we start by considering the CAMPL commands. Corresponding to every concurrent MPL construct, there is one CAMPL command. Table \ref {concurrent-commands} lists the concurrent commands with a brief description of each. The execution of CAMPL commands have been described by describing the role of {\bf Process Manager} and {\bf Channel Manager} for each command. {\bf Process Manager's} role is described in  {\bf Process Manager Actions} (see section \ref {process-manager}) and {\bf Channel Manager's} role is described in {\bf Channel Manager Actions} (see section  \ref {channel-manager}).   

\begin{table}[!h]
\begin{center}

\begin{tabular}{l||l}
${\sf get}~\alpha$; C & get a value on channel $\alpha$ \\
${\sf put}~\alpha$; C & put a value on channel $\alpha$ \\ \hline
${\sf split}~\alpha~{\sf into}~(\alpha_1,\alpha_2); C$ & split channel $\alpha$ into two (new) channels \\
$\!\!\!\begin{array}{ll}{\sf fork} & \alpha~{\sf as} \\
                           & \alpha_1~{\sf with}~\Gamma_1. C_1 \\
                           & \alpha_2~{\sf with}~\Gamma_2. C_2  \end{array}$ & forking on a channel into two distinct processes \\ \hline

${\sf hput}~\alpha~n; C$ & put a ``handle'' on channel $\alpha$ \\
${\sf hcase} \{ C_1,..,C_n\}$ & the cases on receiving a ``handle'' \\ \hline 

${\sf close}~ \alpha; C$ & closing a channel \\
${\sf halt}~\alpha$ & halting process attached to a single channel \\ \hline

$\!\!\!\begin{array}{ll}{\sf plug} & [\alpha_1,...,\alpha_n] \\
                           & \Gamma_1. C_1 \\
                           & \Gamma_2. C_2  \end{array}$ & two processes to communicate on $n$ channels \\ \hline 
${\sf run}~t~\< {\tt process} \>$ & runs a process with local channel to caller channel translation $t$ \\ \hline 


${\sf id}~\alpha = \beta$ & identifying channels.
\end{tabular}
\caption{Basic Concurrent Commands}
\label{concurrent-commands}
\end{center}
\end{table}

\subsubsection{Process Manager's Actions}{\label{process-manager}}
This section describes the execution step corresponding to the CAMPL commands. When a command executes it not only changes the state of the running process shown by ${\cal P}\{ (s,t,e,c)\}$ but may also change the state of the queues associated with a channel. Hence, the {\bf Transition Table} for CAMPL (described in Table \ref {process-actions}) have columns for both {\bf Process Manager} and {\bf Channel Manager} in the {\bf before} and the {\bf after} column.
An explanation of the {\bf Process Manager's} actions corresponding to the various CAMPL commands is provided below:
\begin{itemize}
\item {\bf Get/Put:} These are the two basic communication commands. ${\sf put}$ transmits a value on a communication channel and ${\sf get}$ receives a value on a communication channel.  To ${\sf put}$ a value on a channel one simply 
places the value on the input queue for that channel. To ${\sf get}$ a value the process suspends itself on the communication channel with the demand for a value.   When the value appears (is put) on the channel the communication manager  
passes the value and enables the process waiting to get the value.

\item {\bf Split}: The ${\sf split}$ instruction splits the channel $\alpha$ into two channels ($\alpha_1$ and $\alpha_2$).  One therefore adds to the appropriate queue notification of the two ``global'' channels into which the channels are split. This means one must choose two new channel names (here $\beta_1$ and $\beta_2$), and must remember the translation from the local channel names, $t[\beta_1/\alpha_1,\beta_2/\alpha_2]$. Once {\sf split} is done, the machine continues with the execution of the remaining code.    

\item {\bf Fork}: {\sf Fork} command is dual to the {\sf split} command is the ${\sf fork}$ command.  This command creates two processes which are supposed to communicate on the new channels assigned by a  split command. However, the splitting may not have happened when the fork command is executed. Thus, on a fork command the process suspends itself and attaches itself to the channel which is to be split. The process does not fork, however 
until the corresponding channel action of splitting is performed (as a communication action)  ... and at that stage the translations for the local channel names to global names are adjusted and the forked processes are 
enabled (i.e. added into the process manager).

\item {\bf Plug}: The ${\sf plug}$ command allows two processes to communicate along certain of their channels. A plug command is a command in a process which has certain channels connecting it to the outside world.  As in a fork command 
these channels must be divided amongst the two process being plugged together: in addition, new global communication channels must be assigned to the channels along which they wish to communicate. After a plug command both 
processes are enabled (i.e. added into the process manager).

\item {\bf Handle}: The ${\sf hput}$ command, which sends a ``handle'' -- a protocol constructor -- which is matched by a listening process which will react according to which handle is received by an ${\sf hcase}$ command.  These commands behave 
somewhat like a ``put''  and ``get'', except that for the latter one chooses the code which is to be run based on the handle received rather than simply using the value in the subsequent code.

\item {\bf Call}: This ``jumps'' to some code for a predefined process.  The only subtlety in the ${\sf call}$ command is that one must start by setting up the translation of the local channels of the predefined process into global channel names.

\item {\bf Close/Halt}: Closing a channel, ${\sf close}~\alpha$, causes the channel to be removed.  Corresponding to closing a channel is the ${\sf halt}$ command.  Only when all other channels of a process have been closed can a process call a ${\sf halt} ~\alpha$ on the one remaining channel.

\item {\bf Id~$\alpha := \beta$}: This provides an identity map between two channels.  It alters the translation of the process by defining the translation of $\alpha$ to be the same as the translation of $\beta$.   This command is used, in particular, when ``bending'' wires to simulate the negation of linear logic.
\end {itemize}

\begin{table}
\begin{center}
\begin{tabular}{|l|l||l|l|} \hline
${\cal C}\{ (t(\alpha), q'\mid q) \} $ & ${\cal P}\{ (s,t,e,{\sf get}~\alpha;c) \}$ 
   & ${\cal C}\{ (t(\alpha),q' \mid q\!\!:\!\!{\sf g}(s,t,e,c)) \}$ & ${\cal P}\{ \}$ \\ \hline
${\cal C}\{ (t(\alpha),q' \mid q)\}$ & ${\cal P}\{ (v\!\!:\!\!s,t,e,{\sf put}~\alpha;c) \}$ & 
${\cal C}\{ (t(\alpha),q' \mid q\!\!:\!\!v)\} $ & ${\cal P}\{ (s,t,e,c) \}$ \\ \hline
${\cal C}\{ (t(\alpha), q' \mid q) \}$ & ${\cal P}\{ ([],t,e,\!\!\!\begin{array}[c]{r}{\sf split}~\alpha~{\sf into}\\ ~(\alpha_1,\alpha_2); c \end{array}\!\!\!) \} $ &
         ${\cal C}\left\{ \!\!\!\begin{array}[c]{l} \!\!\left(\!\!\!\begin{array}[c]{l} t(\alpha), \\ q' \mid q\!\!:\!\! \< \beta_1,\beta_2 \>\end{array} \!\!\!\right) \!\!\\ (\beta_1,\varepsilon) \\ (\beta_2,\varepsilon) \end{array} \!\!\!\!\right\}$ & ${\cal P}\{ ([],t \!\left[ \!\!\!\begin{array}{l} \beta_1/\alpha_1\\ \beta_2/\alpha_2 \end{array} \!\!\!\right]\!,e,c) \}$ \\ \hline
${\cal C}\{ (t(\alpha),q'\mid q) \}$ & ${\cal P}\{ (s,t,e,{\sf close}~\alpha;c)\} $ & ${\cal C}\{ t(\alpha),q' \mid q\!\!:\!\!{\sf close}) \}$ & ${\cal P}\{ (s,t\backslash\alpha,e,c)\}$ \\ \hline
${\cal C}\{ (t(\alpha),q' \mid q) \}$ & ${\cal P}\{ ([],t,e, \!\!\!\!\!\begin{array}[c]{l}{\sf fork} ~ \alpha~{\sf as} \\
                           ~\alpha_1~{\sf with}~\Gamma_1. c_1 \\
                           ~\alpha_2~{\sf with}~\Gamma_2. c_2  \end{array}\!\!,[]) \} $ 
              & ${\cal C}\{\!\! \left(\!\!\!\begin{array}{l} t(\alpha),\\ q'\mid q\!\!:\!\!\left[t,e,\!\!\!\begin{array}[c]{l} \alpha_1/\Gamma_1. c_1 \\ \alpha_2/\Gamma_2. c_2 \end{array} \!\!\!\right] \end{array}\!\!\!\right)\!\!\}$ & ${\cal P}\{\}$ \\ \hline
${\cal C}\{ \}$ & ${\cal P}\{ ([],t,e, {\sf id}~ \alpha:=\gamma;  c ,[]) \} $ 
              & ${\cal C}\{ \} $ & ${\cal P}\left\{ \! ( [],t[t(\gamma)/\alpha],e,c) \! \right\}$ \\ \hline
${\cal C}\{ \}$ & ${\cal P}\{ ([],t,e, \!\!\!\!\!\begin{array}[c]{l}{\sf plug} [\alpha_1,...,\alpha_n]\\
                           ~~~\Gamma_1. c_1 \\
                           ~~~\Gamma_2. c_2  \end{array}\!\!,[]) \} $ 
              & ${\cal C}\{ (\gamma_i,\varepsilon\mid\varepsilon)_{i=1...n}\} $ & ${\cal P}\left\{ \!\!\!\begin{array}[c]{r} ( [],t[\gamma_i/\alpha_i]_{\Gamma_1},e,c_1), \\ ([],t[\gamma_i/\beta_i]_{\Gamma_2},e,c_2) \end{array} \!\!\! \right\}$ \\ \hline
${\cal C}\{ (t(\alpha),q'\mid q) \}$ & ${\cal P}\{ ([],t,e,{\sf halt}~\alpha)\} $ & ${\cal C}\{ t(\alpha),q' \mid q\!\!:\!\!{\sf halt}) \}$ & ${\cal P}\{ \}$ \\ \hline
${\cal C}\{\}$ & ${\cal P}\{ (s,t,e,{\sf run}~t'~c) \}$ & ${\cal C}\{\}$  & ${\cal P}\{ (s,t;t',e',c) \}$ \\ \hline
${\cal C}\{ (t(\alpha),q' \mid q)\}$ & ${\cal P}\{ (s,t,e,{\sf hput}~\alpha~n;c) \}$ & 
${\cal C}\{ (t(\alpha),q' \mid q\!\!:\!\!{\sf h}(n))\} $ & ${\cal P}\{ (s,t,e,c) \}$ \\ \hline
${\cal C}\{ (t(\beta), q' \mid q) \} $ & ${\cal P}\{ (s,t,e,{\sf hcase} ~\beta~\{ c_i \}) \}$ & ${\cal C}\{ (t(\beta), q' \mid q\!\!:\!\!(s,t,e,{\sf hc}\{ c_i\})) \} $ & ${\cal P}\{ \}$ \\ \hline
\end{tabular}
\end{center}
\caption{Process execution steps ($\alpha$ with input polarity)}
\label{process-actions}
\end{table}

\subsubsection{Channel Manager's Actions}{\label{channel-manager}} \label{ChanManAct}
This section describes how CAMPL deals with the dual command pairs of {\sf get-put}, {\sf hput-hcase}, {\sf split-fork} and {\sf close-halt} when {\sf get} occurs before {\sf put}, {\sf hcase} occurs before {\sf hput}, {\sf fork} occurs before {\sf split}. These commands are discussed with respect to conventional channels and not {\bf Services}. {\bf Channel Manager's Actions} for {\bf Services} are discussed in Section \ref {channel-man-serv}.
~~\\~~\\
An explanation of the {\bf Channel Manager's} actions:
\begin{itemize}
  \item {\bf Communication of values or a handle}:
When a value/handle is waiting on a channel and there is a suspended process waiting for the value then one can transmit the value and re-enable the process which was waiting. Row 1 of Table \ref {channel-actions} shows the communication of {\sf values}. Row 2 shows the communication of a {\sf handle} facilitated by the {\bf Channel Manager}.

\item {\bf Split/Fork communication}:
When a suspended process which wishes to fork is waiting on a channel and the corresponding split has been made on the channel one assigns new global channel names to the channels introduced by the fork and enable the processes which are forked modifying the translations of the processes. Row 3 of Table \ref {channel-actions} shows the ${\sf split-fork}$ communication facilitated by the {\bf Channel Manager}.

\item {\bf Close/Halt communication}:
A channel can be completely removed from the channel manger only when a ${\sf close}$ command matches a ${\sf halt}$ command. This is shown by the row 4 of Table \ref {channel-actions}.
\end{itemize}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l||l|l|} \hline
${\cal C}\{ (\beta , q\!\!:\!\!v \mid {\sf g}(s,t,e,c)) \}$ & ${\cal P}$ & ${\cal C}\{ (\beta,q \mid \varepsilon) \}$ & ${\cal P}\{(v\!\!:\!\! s,t,e,c)\}$ \\ \hline
${\cal C}\{ (t(\beta) , q\!\!:\!\!{\sf h}(i)  \mid (s,t,e,{\sf hc} ~\{ c_j \})) \}$ & ${\cal P}$ & ${\cal C}\{ (\beta,q \mid \varepsilon) \}$ & ${\cal P}\{(s,t,e,c_i)\}$ \\ \hline
${\cal C}\{ (\beta, \<\beta_1,\beta_2\> \mid \left[t,e,\!\!\!\begin{array}[c]{l} \alpha_1/\Gamma_1. c_1 \\ \alpha_2/\Gamma_2. c_2 \end{array} \!\!\!\right] \} $ & ${\cal P}$ 
                     & ${\cal C}\{ \}$ & ${\cal P}\left\{ \!\!\!\begin{array}{r} ([],t_{\Gamma_1}[\beta_1/\alpha_1],e,c_1), \\
                                              ([],t_{\Gamma_2}[\beta_2/\alpha_2],e,c_2) \end{array} \!\!\!\right\}$ \\ \hline
${\cal C}\{ (\beta,{\sf close}\mid {\sf halt} ) \}$ & ${\cal P}$ & ${\cal C}\{ \}$ & ${\cal P}$ \\ \hline
\end{tabular}
\caption{Channel Manager's Actions for Normal Channels}
\label{channel-actions}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Channel Manager's Actions for Services}{\label{channel-man-serv}}
Services are built in channels in MPL that allow an MPL program to interact with the outside world. Differences in {\bf Channel Manager's} behaviour for services follow from the fact that {\bf Services} are different from conventional channels:
\begin{itemize}
  \item Conventional channels are connected to two MPL processes on their two ends whereas {\bf Services} are connected to just one process.
  \item Actions like {\sf plug}, {\sf split} and {\sf fork} can't be done on {\bf Service} channels. Permissible actions on {\bf Services} are {\sf hput}, {\sf get-put} and {\sf close-halt}.
\end{itemize}
The standard way to use a {\bf Service} channel is to {\sf hput} a handle on it and then do any of the {\sf get, put, close, or halt} actions. A protocol commonly used with an output {\bf Service} channel has been defined in Figure \ref {AMPL:ProtExample}. The name of the protocol is {\bf IntTerm} and one can recursively {\sf get-put} on a {\bf Service} and {\sf close} a {\bf Service} using the handles {\bf GetInt}, {\bf PutInt} and {\bf Close} respectively.
\begin{figure}[!h]
\begin{alltt}


                    protocol IntTerm (A) => P =
                        GetInt   :: Get (A|P) => P 
                        PutInt   :: Put (A|P) => P
                        Close    :: Top       => P  

\end{alltt}
\caption{Example : Protocol Definition for an Output Service Channel}
\label {AMPL:ProtExample}
\end{figure}
The {\bf Channel Manager's} actions for an output {\bf Service} channel have been described in Table \ref {channel-actions-Serv}. In Table \ref {channel-actions-Serv}, ${\sf h}(1),~{\sf h}(2)$ and ${\sf h}(3)$ refer to the first, second and the third handle respectively. 
\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l||l|l|} \hline
${\cal C}\{ (\beta , \varepsilon \mid \varepsilon :{\sf h}(1):{\sf get}) \}$ &  ${\cal P}\{(s,t,e,c)\}$ & ${\cal C}\{ (\beta,\varepsilon \mid \varepsilon) \}$ & ${\cal P}\{(v\!\!:\!\! s,t,e,c)\}$ \\ \hline

${\cal C}\{ (\beta , \varepsilon \mid \varepsilon :{\sf h}(2):{\sf v}) \}$ & ${\cal P}\{(v\!\!:\!\! s,t,e,c)\}$ & ${\cal C}\{ (\beta,\varepsilon \mid \varepsilon) \}$ & ${\cal P}\{(s,t,e,c)\}$\\ \hline

${\cal C}\{ (\beta , \varepsilon \mid \varepsilon :{\sf h}(3):{\sf close}) \}$ & ${\cal P}$ & ${\cal C}~\backslash~\beta $ & ${\cal P}$ \\ \hline

${\cal C}\{ (\beta , \varepsilon \mid \varepsilon :{\sf h}(3):{\sf halt}) \}$ & ${\cal P}$ & ${\cal C}~\backslash~\beta $ & ${\cal P}$ \\ \hline


\end{tabular}
\caption{Channel Manager's Actions for Services(Output Channel $\beta$)}
\label{channel-actions-Serv}
\end{center}
\end{table}

\subsubsection {Example : Compiling and Executing Concurrent MPL Programs}
This section shows an example of compiling and executing Concurrent MPL commands on CAMPL. 
~~\\~~\\
In Table \ref {AMPL : CAMPLExample} a simple MPL program is taken and its compiled CAMPL code is provided with the description of what each command does. The given MPL program consists of just one process, the {\bf main process} which takes two numbers on an output {\bf Service} channel named {\bf intTerm1}, sums the numbers and displays them on the same {\bf Service}. 
~~\\~~\\ 
In Table \ref {AMPL:ExecConcTable} and \ref {AMPL:ExecConcTableRem}, the CAMPL code from Table \ref {AMPL : CAMPLExample} is executed stepwise based on the {\bf Channel Manager's Actions for Services} from Table \ref {channel-actions-Serv}  and the {\bf Process Execution Steps} from Table \ref {process-actions}, till the final state is reached. If the program had normal channels in addition to the {\bf Service} channels, then Table \ref {channel-actions} detailing the  {\bf Channel Manager's Actions for Normal Channels} would also be referenced. 
~~\\~~\\ 
In Table \ref {AMPL:ExecConcTable} and \ref {AMPL:ExecConcTableRem},
\begin {itemize}
 \item the notation ${\cal C}~\{n, q \mid q'\}$ for {\bf Channel Manager} means that channel number $n$ has two associated queues, $q$ and $q'$, and  
 \item {\em Translation} represented by $\Gamma$ and is a mapping of local channels to global channels. The translation $\Gamma~\big[\big($~0$,~$0$),\big($-1$,~$-1$)\big]$ means that channels known locally as $0$ and $\texttt{-1}$ are known globally by the same numbers. This is because all the channels in the given program are {\bf Service} channels. {\bf Service} channels are global channels and are known in every process by the same numbers. {\bf Service} channels are represented by numbers less than or equal to 0. 0 is used for a special {\bf Service} channel known as {\bf Console}. 
\end {itemize}
The first row of Table  \ref {AMPL:ExecConcTable} describes the initial state in the execution of the main process. Notice the values of different columns in the first row. The {\bf Channel Manager} starts with empty queues for all the channels in the main process. {\em Stack} and {\em Environment} are empty and {\em Translation} is loaded with local to global mapping of channels of the main process. {\bf Code} is initialised to the compiled CAMPL code for the process generated in Table \ref {AMPL : CAMPLExample}.
~~\\~~\\ 
Last row of Table \ref {AMPL:ExecConcTableRem} describes the final state in the execution of the main process. Every column is empty except the {\bf stack} which contains the sum of the numbers (output) as its top element.
\begin{table}[h!]
\begin{center}
\begin{tabular}{|c|c|} \hline
{}& {}\\
{\bf Before} & {\bf After} \\ 
{}& {}\\
\hline
\begin{minipage}{2.5in}
{
\begin{alltt}


  protocol IntTerm (A) => P =
      GetInt   :: Get (A|P) => P 
      PutInt   :: Put (A|P) => P
      Close    :: Top       => P  

  coprotocol CP => Console (A) =
      GetIntC   :: CP => Put (A|CP)  
      PutIntC   :: CP => Get (A|CP) 
      CloseC    :: CP => TopBot  

  run console => intTerm1 -> do
      hput GetInt on intTerm1
      get num1 on intTerm1
      hput GetInt on intTerm1
      get num2 on intTerm1
      hput PutInt on intTerm1
      put (num1+num2) on intTerm1
      hput Close on intTerm1
      close intTerm1
      hput CloseC on console
      halt console


\end{alltt}

} 
\end {minipage} &
\begin{minipage}{4in}
{
\begin{alltt}

     {\it   -- put first handle on channel -1 which is a service 
          -- channel called intTerm1.First handle suggests get 
          -- action on -1} 
       hput -1 1
       get -1     {\it -- get a value on channel -1}
       store      {\it -- store the value obtained from -1}
     {\it   -- get another value from -1 and store} 
       hput -1 1
       get -1
       store 
       access 2   {\it -- load the second number}
       access 1   {\it -- load the first number}
       add        {\it -- add the two numbers}

     {\it   -- put second handle on channel -1. Second Handle 
          -- suggests a value will be put on -2}
       hput -1 2  
       put -1     {\it -- put the sum on channel -1} 

     {\it   -- put third handle on channel -1. Handle 3 
          -- suggests that channel will be closed.}    
       hput -1 3
       close -1   {\it -- close channel -1}
       hput \(0\) 3   {\it -- put third handle on channel 0}
       halt \(0\)     {\it -- halt channel 0}

\end{alltt}
}
\end {minipage}
\tabularnewline
\hline
\end{tabular}
\caption{Example : Compilation of Concurrent MPL Program to CAMPL}
\label{AMPL : CAMPLExample}
\end{center}
\end{table}


\begin{table}
\begin{center}
  \begin{tabular}{|l||l|l|l|l|}
  \hline
    Channel Manager & Stack & Trans & Env & Code \\
    \hline 
    %%%%%%%%%%%%% 1%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
               \begin{array}[c]{l}
               \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
               \big($-1$,\varepsilon~\mid~\varepsilon\big)
               \end{array}   
            \bigg\}
    $ &
    $\varepsilon$ &
    $\Gamma~\bigg[
               \begin{array}[c]{l}
               \big($~0$,~$0$),\\
               \big($-1$,~$-1$)
               \end{array}   
            \bigg] 
    $ &
    $\varepsilon$ &
    ${\sf hput}~\texttt{-1~1}:~c_1$\\
    {}&{}&{}&{}&{}\\   
    \hline 
    %%%%%%%%%%%%% 2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
               \begin{array}[c]{l}
               \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
               \big($-1$,\varepsilon~\mid~\varepsilon:$h(1)$\big)
               \end{array}   
            \bigg\}
    $ &
    $\varepsilon$ &
    $\Gamma~\bigg[
               \begin{array}[c]{l}
               \big($~0$,~$0$),\\
               \big($-1$,~$-1$)
               \end{array}   
            \bigg] 
    $ &
    $\varepsilon$ &
    ${\sf get}~\texttt{-1}:~c_2$\\ 
    {}&{}&{}&{}&{}\\
    \hline 
    %%%%%%%%%%%%% 3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}$(1):{\sf get}$\big)
                   \end{array}   
                \bigg\}
        $ &
        $\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $\varepsilon$ &
        $~c_2$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
        %%%%%%%%%%%%% 4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $\varepsilon$ &
        ${\sf store}:~c_3$\\
        {}&{}&{}&{}&{}\\   
        \hline 
        %%%%%%%%%%%%% 5 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_1:\varepsilon$ &
        ${\sf hput}~\texttt{-1~1}:~c_4$\\
        {}&{}&{}&{}&{}\\   
        \hline 
    %%%%%%%%%%%%% 6 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
               \begin{array}[c]{l}
               \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
               \big($-1$,\varepsilon~\mid~\varepsilon:$h(1)$\big)
               \end{array}   
            \bigg\}
    $ &
    $\varepsilon$ &
    $\Gamma~\bigg[
               \begin{array}[c]{l}
               \big($~0$,~$0$),\\
               \big($-1$,~$-1$)
               \end{array}   
            \bigg] 
    $ &
    $v_1:\varepsilon$ &
    ${\sf get}~\texttt{-1}:~c_5$\\ 
    {}&{}&{}&{}&{}\\
    \hline 
    %%%%%%%%%%%%% 7 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}$(1):{\sf get}$\big)
                   \end{array}   
                \bigg\}
        $ &
        $\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_1:\varepsilon$ &
        $~c_5$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
        %%%%%%%%%%%%% 8 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_1:\varepsilon$ &
        ${\sf store}:~c_6$\\
        {}&{}&{}&{}&{}\\   
        \hline 
        %%%%%%%%%%%%% 9 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf access~\texttt{2}} :~c_7$\\
        {}&{}&{}&{}&{}\\   
        \hline 
        %%%%%%%%%%%%% 10 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf access~\texttt{1}} :~c_8$\\
        {}&{}&{}&{}&{}\\   
        \hline 
        %%%%%%%%%%%%% 11 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_2:v_1:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf add} :~c_9$\\
        {}&{}&{}&{}&{}\\   
        \hline 
        %%%%%%%%%%%%% 12 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $\texttt{$v_1\texttt{+}v_2$}:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf hput}~\texttt{-1~2} :~c_{10}$\\
        {}&{}&{}&{}&{}\\   
        \hline 
  \end{tabular}
  \caption{Executing Code on CAMPL (Continued On Table \ref {AMPL:ExecConcTableRem})}
  \label{AMPL:ExecConcTable}
  \end{center}
  \end{table}


\begin{table}
\begin{center}
  \begin{tabular}{|l||l|l|l|l|}
  \hline
    Channel Manager & Stack & Trans & Env & Code \\
    \hline 
        %%%%%%%%%%%%% 12 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        {}&{}&{}&{}&{}\\
        $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}(2)\big)
                   \end{array}   
                \bigg\}
        $ &
        $\texttt{$v_1\texttt{+}v_2$}:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf put}~\texttt{-1} :~c_{10}$\\
        {}&{}&{}&{}&{}\\   
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}$(2):{\sf put}$\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        $~c_{10}$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf hput}~\texttt{-1~3}:~c_{11}$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}$(3)$\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf close}~\texttt{-1}:~c_{12}$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big),\\
                   \big($-1$,\varepsilon~\mid~\varepsilon:{\sf h}$(3):{\sf close}$\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$),\\
                   \big($-1$,~$-1$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        $~c_{12}$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf hput}~\texttt{$0$~3}:~c_{13}$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon:{\sf h}$(3)$\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        ${\sf halt}~\texttt{$0$}:~\varepsilon$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{
                   \begin{array}[c]{l}
                   \big($~0$,\varepsilon~\mid~\varepsilon:{\sf h}$(3):{\sf halt}$\big)
                   \end{array}   
                \bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[
                   \begin{array}[c]{l}
                   \big($~0$,~$0$)
                   \end{array}   
                \bigg] 
        $ &
        $v_2:v_1:\varepsilon$ &
        $\varepsilon$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
    {}&{}&{}&{}&{}\\
    $\cal C~\bigg\{~~\bigg\}
        $ &
        $v_1\texttt{+}v_2:\varepsilon$ &
        $\Gamma~\bigg[~~\bigg] 
        $ &
        $\varepsilon$ &
        $\varepsilon$\\ 
        {}&{}&{}&{}&{}\\
        \hline 
  \end{tabular}
  \caption{Executing Code on CAMPL (Continued from Table \ref {AMPL:ExecConcTable})}
  \label{AMPL:ExecConcTableRem}
  \end{center}
  \end{table}

%${\sf hput}~\texttt{-1~3} :~c_{11}$\\ 
\end {document}


\documentclass[11pt]{article}

\title{Type System for MPL}
\usepackage{amsmath }
\usepackage{framed}
\usepackage{proof}
\usepackage{enumerate,xspace,stmaryrd}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{graphicx}
\usepackage{textcomp,xspace}
\usepackage[top=2cm, bottom=2.5cm, right=2.5cm, left=2.5cm]{geometry}
\usepackage{latexsym}  %For plain TeX symbols, such as \Box used in \qed
\usepackage{euscript}  %%Euler Script font
\usepackage {mdframed}
\usepackage{ifpdf}
\ifpdf
  \usepackage{epstopdf}
\fi 
\usepackage{etoolbox}
\BeforeBeginEnvironment{tabular}{\begin{center}\small}
\AfterEndEnvironment{tabular}{\end{center}}


\mdfdefinestyle{MyFrame}{%
    linecolor=black,
    linewidth=1pt
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    leftmargin  = 2cm
    rightmargin = 2cm,
    frametitlealignment = \center
    }

\mdfdefinestyle{MyFrameSp}{%
    linecolor=black,
    linewidth=1pt
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    leftmargin  = .5cm
    rightmargin = .5cm,
    frametitlealignment = \center
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Special symbol macros ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\x}{\times}
\newcommand{\PhiGamma} {\Phi~|~\Gamma}
\newcommand{\Gvdash} {\Gamma \vdash}
\newcommand{\VdashDel} {\Vdash \Delta} 
\newcommand{\ox}{\otimes}
\newcommand{\context}[2]{#1 \left[\hspace{-1.7pt}\left[ #2 \right]\hspace{-1.7pt}\right]}
\newcommand{\bag}[1]{\{\hspace{-2.5pt}[ #1 ]\hspace{-2.5pt}\}}
\newcommand{\cons}{\ensuremath{{\sf cons~}}\xspace}
\newcommand{\dest}{\ensuremath{{\sf dest~}}\xspace}
\newcommand{\get}{\ensuremath{{\sf get ~ x ~\alpha~}}\xspace}
\newcommand{\putC}{\ensuremath{{\sf put ~ x ~\alpha~}}\xspace} 
\newcommand{\close}{\ensuremath{{\sf close ~\alpha~}}\xspace}
\newcommand{\halt}{\ensuremath{{\sf halt ~\alpha~}}\xspace}
\newcommand{\plug}{\ensuremath{{\sf plug ~ (\alpha_1,\ldots,\alpha_n) ~(s_1,s_2)}}\xspace}

\newcommand{\splitC}
    {
     \ensuremath{{\sf split ~~\alpha~~ (\alpha_1,\alpha_2)}}
     \xspace
    }


\newcommand{\fold}[2]{\begin{array}{l}
                        {\sf fold~} #1 \\
                        {\sf ~of~} 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\newcommand{\fork}[2]{\begin{array}{l}
                        {\sf fork~} #1 \\
                        {\sf ~~as~}
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}


\newcommand{\case}[2]{\begin{array}{l}
                        {\sf case~} #1 \\
                        {\sf ~of~} 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\newcommand{\rec}[1]{\begin{array}{l}
                        {\sf rec~} \\
                        {\sf ~of~}
                        \left| \begin{array}{lcl} #1 \end{array} 
                        \right.\end{array}}

\newcommand{\letS}[2]{\begin{array}{l}
                        {\sf let ~} #1 \\
                        {\sf ~where~} \\
                        ~~~\left|\begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}


\newcommand{\fun}[1]{\begin{array}{l}
                        {\sf fun~ f} \\~~ 
                        \left| \begin{array}{lcl} #1 \end{array} 
                        \right.\end{array}}

\newcommand{\funT}[2]{\begin{array}{l}
                        {\sf fun~ f~::~} #1 \\~~ 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\begin{document}

\maketitle

\section {Introduction}
In this chapter, we describe type inference for MPL. we have a look at the generation of type equations for the Sequential MPL (terms and functions) is dicussed followed by the generation of type equation for Concurrent MPL. Finally, we look at an algorithm to solve the type equations to get the most general type.
\section {Type Formation Rules}
Let T be a set of atomic types (type variables), $\Omega$ be a set of type formation symbols for user defined data/codata types like Tree,List etc. $\omega$ is a function called \emph{arity} that describes the number of parameters that the type needs.
\begin{align*}
    \omega ~ : ~ \Omega ~ \to ~ \mathbb {N}  
\end{align*}
Type formation rules describes the rules for the construction of valid types from the elements of T.
~~\\~~\\ 
The type formation rules for MPL are given by the rules in the below table.  
\begin{mdframed} [style=MyFrame,userdefinedwidth=12cm,align=center,
                  frametitle=Type Formation Rules,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer []
  {
    A ~~~ type   
  }
  { 
    A \in T
  }
~~\\~~\\
\infer [prod]
  {
    A_1 \times \ldots \times A_n ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type  
  }
~~\\~~\\~~\\ 
\infer [data ~ type]
  {
    D~(A_1 \ldots A_n) ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type  \hskip 2em \omega (D)~ =~ n 
  }
~~\\~~\\~~\\ 
\infer [codata ~ type]
  {
    C~(A_1 \ldots A_n) ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type \hskip 2em \omega (C)~ =~ n 
  }

\end{mdframed}
~~\\~~\\
Notice that data types and codata types are formed using the same typing rules. However they have been differentiated here because data types and codata types are used differently in MPL.
~~\\~~\\
\section {Term Formation Rules for Sequential Terms}
Here the type inference rules for the various sequential MPL constructs are dicussed. The type inference rules can be thought of as term formation rules enhanced with the typing information of the constituting terms.
\subsection {Variable Term}
% ---------------------------------------------------
% ---------------------- Var -----------------------
% ---------------------------------------------------
In order to infer a variable which is a sequential term,the variable should be looked up in the context. If it is present in the context, then the type variable corresponding to the var term should be equated with the variable type from the context.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=8cm,align=center,
                  frametitle=Typing rule for variable ,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm id]
  {
    x:P , \Gamma \vdash x : Q  
    ~~~ \bigg\langle P = Q 
        \bigg\rangle 
  }
  { 
  }
\end{mdframed}
~~\\~~\\
% ---------------------------------------------------
% ----------------------call-------------------------
% ---------------------------------------------------
\subsection {Function Call}
Let $\Omega$ be a set of function symbols,$T_y^*$ be the set of input types and $T_y$ be the set of output types. $\sigma$ is a function of the below type that returns as output the the input and output types of a function symbol.
$\omega : \Omega \to T_y^* \times T_y$

~~\\~~\\
$\sigma$ is defined both for inbuilt functions as well user defined functions. Example of $\sigma$ for inbuilt functions is below. 
\begin{align*}
    & \sigma (+_{Int}) ~~ = ~~ ([Int,Int],Int) ~~\\ 
    & \sigma ('s') ~~~~~ = ~~ ([~],Char)
\end{align*}
Consider a user defined function factorial which takes an integer as the input and outputs the factorial of the integer. The type of the output is also an integer. $\sigma$ for factorial is defined below.
\begin{align*}
    & \sigma (fact) ~~ = ~~ ([Int],Int)  
\end{align*}
Consider a function f taking m inputs of types $S_1$, $\ldots$ $S_m$ and the output type S. 
\begin{align*} 
 & f:\forall A_1,~ \ldots,~A_k.~S_1,\ldots,S_m \to S 
\end{align*}
~~\\~~\\
\subsubsection {$\alpha$-renaming function constructs}
 \label{alpha}
Consider two terms $t_1$ and $t_2$ for which the equations $\exists~a,b.~a \times b$ and $\exists~a.~a \times a$ are generated. It is intended to equate $t_1$ and $t_2$ which means that their type equations need to be unified. 
\begin{align}
     \exists~a,b.~a \times b = \exists~a.~(a \times a)\times a
 \end{align} 
Unification would be dicussed in details in section but the intent here is to force $a ~ = ~ b$. However, we also end up with an $a ~ = ~ a \times a $ which fails occurs check suggesting that the two equations can't be unified. To avoid this problem, $\alpha$-renaming is used which replaces variables on both the sides of the equations with fresh variables. Thus, $\alpha$-renaming will generate the below type equation.
\begin{align}
     \exists~a_1,b_1.~a_1 \times b_1 = \exists~a_2.~(a_2 \times a_2)\times a_2
 \end{align} 
Unification of the above equations yields $a_1 =~ (a_2 \times a_2)$ and $b_1 = a_2$ which is the desired solution.
~~\\~~\\
The output and input types of the function $f$ are $\alpha$-renamed before using these constructs in the type equations. This is done to avoid any name clashes between the variables of the function and the variables already used in the equation.
\begin{align*}
 & ~~ S_{i}^\prime = (\Lambda A_1,\ldots,A_k.~S_i)~A_1^{\prime},\ldots,A_k^{\prime} ~~~ \{~ 1~ \leq~ i~ \leq m\} \\
 & ~~ S^{\prime} = (\Lambda A_1,\ldots,A_k.~ S)~A_1^{\prime},\ldots,A_k^{\prime} 
 \end{align*}
\subsubsection {Type Equations for Function Call }
The table $givetabref$ shows the term formation rule for function call.
~~\\ 
 \begin{mdframed} [style=MyFrameSp,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for function call,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
{\small
\infer [\rm call]
  {
    \Gamma \vdash {\sf f ~(x_1,\ldots,x_m)}
   : T  ~~
       \Bigg\langle 
                \exists \,
                \begin
                  {array}[c]{l}
                  A_1^{\prime},\ldots,A_k^{\prime},\\
                  T_1,\ldots,T_m ~~.~
                \end{array}
                \begin {array}[c]{l} 
                   T = S^{\prime},\\
                   T_1 = S_{1}^\prime,\ldots,T_m = S_{m}^\prime ,\\
                   E_1,\ldots,E_m
                \end{array} 
            \Bigg\rangle 
  }
  { \Gvdash  x_1 : X_1 ~~\langle E_1 \rangle && \ldots &&
    \Gvdash  x_n : X_n ~~\langle E_n \rangle 
  }
}  
\end{mdframed}

\begin{itemize}
   \item The type of a function call is the output type of the function being called.
   \item The type of the various input parameters of the function call can be  deduced from the input types of the function being called.
 \end{itemize} 

% ---------------------------------------------------
% ---------------------- Constants-------------------
% ---------------------------------------------------
\subsection {Constant Term}
\emph {constants} are function of arity 0. They have been presented in a different section for the ease of understanding. constants can be one of the built in constant types, like int, double and char.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=10cm,align=center,
                  frametitle=Typing rule for constants,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\
\infer [\rm int]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Int 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n:Int
  }~~\\~~\\

\infer [\rm double]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Double 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n : Double
  }~~\\~~\\

\infer [\rm char]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Char 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n : Char
  }

\end{mdframed}
% ---------------------------------------------------
% ---------Constructor/Destructor--------------------
% ---------------------------------------------------
~~\\~~\\
\subsection {Terms for Data Types}
A data type in MPL can be thought of as a construct that allows three terms to be defined over it, namely constructor, case and fold. 
\subsubsection {Data Type Declaration}\label{dataDef}
Let us define a data type D($A_1$, $\ldots$, $A_k$) and $C_1$ $\ldots$ $C_m$ be its data constructors. The data type D ($A_1$, $\ldots$, $A_k$)  is polymorphic in type variables $A_1$, $\ldots$, $A_k$.

\begin{align*} 
\forall A_1,~ \ldots,~A_k.~data~ D(A_1,\ldots,A_k)  ~\to~ A =
 & ~~ C_1 : F_{11},~ \ldots, ~ F_{1a} ~~~~~\to ~~~ A \\
 & ~~~~ \vdots \hskip 4em \vdots \hskip 7em \vdots \\ 
 & ~~ C_m : F_{m1},~ \ldots, ~ F_{mn} ~~\to ~~~ A
\end{align*}
An example of a data definition can be the a List(A).
\begin{align*}
    \forall A.~data ~~ List(A)~ =~ & Nil \\ 
                               ~& Cons (A)
\end{align*}
This is a polymorphic list meaning $A$ can be any type, for example $Int,~Char,~List(Char)$. Replacing A with these types would return $List(Int),~List(Char)$ and $List(List(Char))$ respectively. 
~~\\~~\\ 
The different constructs of the data type definition above are $\alpha$-renamed with fresh variable $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ to avoid any naming conflicts when these constructs are used in type equations. The necessity for $\alpha$-renaming was motivated in section~\ref{alpha}. The renamed constructs have been represented by adding a superscript $\prime$ to the name of their names.
~~\\ ~~\\ 
$\Lambda$ is a function that takes as arguments a data construct, the old variables present in that data type construct and the fresh variables to replace the old variables. The output of this function is a data type construct where the old variables in its body have been replaced by the new variables.   

\begin{align*}
 & ~~ D^\prime(A_1^{\prime},\ldots,A_k^{\prime}) ~ = (\Lambda A_1,\ldots,A_k.~ D(A_1,\ldots,A_k))~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} 
 \end{align*}

%% ================================================
%% ================================================
\subsubsection {Constructor, Case and Fold term}
{\sf constructor } term creates a data type with the constructors of that data type.
~~\\~~\\
{\sf case} term branches on the different constructors of a data type. Every branch consists of a constructor and a term as can be seen from the case syntax on page ~ \pageref{caseLab}. The term is executed when the corresponding constructor is selected. 
For constructor $C_1$ which takes {\bf ``a''} number of input terms, $F_{11}$, $\ldots$, $F_{1a}$ repesent the input types of those terms.
~~\\~~\\
fold is used to implement higher order primitive recursive functions which gurantees termination.Like case, fold also has branches corresponding to every constructor of the data type over which one is folding. Every branch has some parameters on the left side of the arrow and a term on the
right side as can be seen in the fold syntax on page 6.
~~\\~~\\ 
For all the constructors of a data type, their fold functions are  inserted in the symbol table.
%% ================================================
%% ================================================

\subsubsection {Type Equations for Constructor Term} 
The function type of a constructor can be looked up from the symbol table.
\begin{itemize}
  \item The output type of the {\sf constructor} term is the output type of the function for that constructor looked up from the symbol table. 
  \item The types of the various parameters of the constructor are the corresponding input types  for that constructor looked up from its function type from the symbol table.
  \item $E_1$, $\ldots$, $E_j$ are the type equations generated for the terms $t_1$, $\ldots$, $t_j$ respectively.
\end{itemize}
\subsubsection {Type Equations for Case Term}
\begin{itemize}
  \item The type of a {\sf case} term is the type of the terms on the right side of the branches.
  \item A well typed case term will have same type for all the terms on the right side of the branches.
  \item The types of the input parameters for a constructor on the left hand side of a branch is obtained by looking up the input types of the function type for that constructor. Teh function type of the constructor is obtained from the symbol table. 
\end{itemize}

\subsubsection {Type Equations for Fold Term}
\begin{itemize}
  \item The type of a {\sf fold} term is the type of the terms on the right side of the branches.
  \item In a well typed {\sf fold} term, all the terms on the right side of the branches will have same type.
  \item The types of the input parameters for a given constructor on the left hand side of a branch is obtained by looking up the fold function type for that constructor from the symbol table.
\end{itemize}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=16.1cm,align=center,
                  frametitle=Typing rule for constructor and case,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm cons]
  { 
    \begin {array} [c]{l}  
        \Gamma \vdash \cons (C_i,[t_{1},\ldots,t_j]):T 
        \hskip 1em
        \left\langle
            \exists \,
            \begin
              {array}[c]{l}
              T_1,\ldots,T_j, \\
              A_1,\ldots,A_n .
            \end{array}
            \begin
              {array}[c]{l} T = D^{\prime}\\
              T_1 = F_{i1}^\prime,\,\ldots,\,T_j = F_{ij}^\prime\\
              E_1,E_2,\ldots,E_j
            \end{array} 
        \right\rangle
    \end {array}
  } 
  { \Gamma \vdash t_1:T_1 ~~~\langle E_1 \rangle && \ldots && ~~~
    \Gamma \vdash t_j:T_j ~~~\langle E_j \rangle
  }~~\\~~\\~~\\

\infer [\rm case]{
      \begin {array} [c] {l}
         \Gamma \vdash 
         \case {t} 
          {
            \begin{array}[c]{lcl}
              {C_1~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {C_m~x_{m1},\ldots,x_{mn}} & \to & t_n 
            \end{array}          
          }:T  \\~~\\ 
          \hskip 6em \Bigg\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_0,T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T_0 = D^\prime(A_1^\prime,\ldots,A_k^\prime),\\
                  T_1 = T,\ldots,T_m = T\\
                  T_{11}= F_{11}^\prime,\ldots,T_{11}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Bigg\rangle  
      \end {array}    
       }
       {
         \Gamma \vdash t:T_0 ~ \langle E_0 \rangle &&
         \begin {array}[c]{lcll} 
             \Gamma,x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
             & \langle E_m \rangle \\
             \hskip 10em \vdots\\ 
             \Gamma,x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
             & \langle E_1 \rangle 
         \end{array} 
       }~~\\~~\\  
\infer [\rm fold] {
    \begin {array}[c]{l}
         \Gamma \vdash 
         \fold {t} 
          {
            \begin{array}[c]{lcl}
              {C_1~:~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {C_m~:~x_{m1},\ldots,x_{mn}} & \to & t_n 
            \end{array}          
          }:T  \\~~\\  
            \hskip 8em \Bigg\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_0,T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T_0 = D^\prime\\ 
                  T_1 = T,\ldots,T_m = T\\
                  T_{11}= F_{11}^\prime,\ldots,T_{11}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Bigg\rangle 
    \end {array} 
       }
       {
         \begin {array}[c]{l}
             \\~~\\
             t:T_0 ~ \langle E_0 \rangle 
         \end {array} && 
             \begin {array} [c] {lcll}             
                 x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
                 & \langle E_m \rangle \\
                 \hskip 10em \vdots \\  
                 x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
                 & \langle E_1 \rangle 
             \end {array}
       }         
\end{mdframed} \label{caseLab}
~~\\~~\\
% ---------------------------------------------------
% -----------------------Record----------------------
% ---------------------------------------------------
\subsection {Terms for Codata Types}
A codata type in MPL can be thought of as a construct that allows three terms to be defined over it, namely destructor, record and unfold.

\subsubsection {Codata Type Declaration}
Consider the codata declaration for a codata type C$(A_1,\ldots,A_k)$. $D_1$, $\ldots$, $D_m$ are the different destructors of the codata type. C$(A_1,\ldots,A_k)$  is polymorphic in type variables $A_1,\ldots,A_k$ which means that $A_1,
\ldots,A_k$ are the type variables used in the different destructors of the codata type. For destructor $D_1$ which takes {\bf ``a''} number of input terms , $F_{11}$, $\ldots$, $F_{1a}$ repesent the types of the input terms.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~codata~ A ~\to~ C (A_1,\ldots,A_k) =
 & ~~ D_1 : F_{11},~ \ldots, ~ F_{1a},~A \to P_1 \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad\qquad \vdots \\ 
 & ~~ D_m : F_{m1} ,~ \ldots, ~ F_{mn},~A \to P_m
\end{align*}
Renaming the different constructs in the codata C$(A_1,\ldots,A_k)$ with fresh variables $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ gives the following constructs. 
\begin{align*}
 & ~~ C^{\prime}(A_1^\prime,\ldots,A_k^\prime)~ = ~(\Lambda A_1,\ldots,A_k.~ C (A_1,\ldots,A_k))~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime ~ =~ (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} \\
 & ~~ P_{i}^\prime ~~~=~ (\Lambda A_1,\ldots,A_k.~ P_i)~A_1^{\prime},\ldots,A_k^{\prime} 
  ~~~~~ \{ 1 \leq i \leq m \} \\
 \end{align*}
\subsubsection {Destructor, Record and Unfold Term} 
{\sf record } term forms a record for a codata type. 
~~\\~~\\
{\sf destructor} destructs a record of a codata type with a particular destuctor of that codata type.It obtains the term corresponding to that destructor from the record.

\subsubsection {Type Equations for Destructor Term}

The function type of a destructor can be looked up from the symbol table. Following details about the type of destructor can be obtained from its function type.
\begin{itemize}
  \item if a destructor takes n parameters, then the corresponding function type of the destructor will have (n+1) input types. The first n types out of the (n+1) types are the types of the corresponding parameters. The $(n+1)^{th}$ type is the codata type of the destructor.

  \item The output type of the destructor is the output type of the function for that destructor looked up from the symbol table.    
\end{itemize}

\subsubsection {Type Equations for Record Term}
\begin{itemize}
  \item The type of a {\sf record} of a codata type is that codata type.
  \item The types of the input parameters to a destructor term can be obtained by looking at the input types of function type of the destructor. The function type of the destructor is obtained from the symbol table.
\end{itemize}

~~\\~~\\ 

\begin{mdframed} [style=MyFrameSp,userdefinedwidth=15cm,align=right,
                  frametitle=Typing rules for record and destructor,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\  
\infer [\rm rec] {
    \begin {array}[c]{l}      
         \Gamma \vdash 
         \rec 
          {
            \begin{array}[c]{lcl}
              {D_1~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {D_m~x_{m1},\ldots,x_{mn}} & \to & t_m 
            \end{array}          
          }:T  \\~~\\ 
            \hskip 6em \Bigg\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T = C^\prime(A_1^\prime,\ldots,A_k^\prime)\\
                  T_1 = P_1^\prime,\ldots,T_m = P_m^\prime\\
                  T_{11}= F_{11}^\prime,\ldots,T_{1a}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Bigg\rangle  
    \end {array}
       }
       {
         \begin {array}[c]{lcll}
         x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
         & \langle E_1 \rangle \\ 
         \hskip 8em \vdots & & \vdots \\ 
         x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
         & \langle E_m \rangle
         \end {array}
       }~~\\~~\\~~\\

\infer [\rm dest]
  { 
   \begin {array}[c]{l}
    {
      \Gamma \vdash \dest (D_i,[t_{i1},\ldots,t_{ij}])
             ~~\Bigg(
             \rec 
              {
                \begin{array}[c]{lcl}
                  \vdots & \vdots & \vdots \\
                  {D_i~x_{i1},\ldots,x_{ij}} & \to & t_i \\
                  \vdots & \vdots & \vdots \\
                \end{array}          
              }\Bigg):T   
    }\\~~\\
    {
      \hskip 6em \Bigg\langle
          \exists \,
          \begin
            {array}[c]{l}
            T_0,T_1,\ldots,T_j, \\
            A_1^{\prime},\ldots,A_n^{\prime}~~~~ .
          \end{array}
          \begin
            {array}[c]{l} 
            T = T_0,\\ 
            T_0 = P_{i}^\prime,
            T_1 = S_1,\ldots,T_j = S_j\\
            S_1 = F_{i1}^\prime,\ldots,S_j = F_{ij}^\prime,\\
            E_0,E_1,\ldots,E_j
          \end{array} 
      \Bigg\rangle 
    }
    \end{array}  
  } 
  { 
    \begin {array} [c] {l}
    \Gamma \vdash t_{i1}:T_1 ~~~\langle E_{i1} \rangle \\ 
    \hskip 5em \vdots \\ 
    \Gamma \vdash t_{ij}:T_j ~~~\langle E_{ij} \rangle 
    \end {array} &&
    \begin {array}[c]{l}
      \\~~\\
      \Gamma, x_{i1}:S_1,\ldots,x_{ij}:S_j \vdash t_i:T_0 
      ~~~ \langle E_0 \rangle
    \end {array}
  }~~\\  
\end{mdframed}
~~\\~~\\


% ---------------------------------------------------
% ---------------------- Prod -----------------------
% ---------------------------------------------------
\subsection {Product Term}
{\sf prod} term is used to represent tuples in MPL. The output type of a tuple is the product of the types of the individual elements.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for prod,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm prod]
  {
    \Gvdash (x_1,\ldots,x_n) : T 
    ~~~ \bigg\langle \exists ~ T_1,\ldots,T_n~.~  
                \begin
                  {array}[c]{l} 
                       T = (T_1,\ldots,T_n) \\ 
                       ,E_1,\ldots,E_n
                \end {array}       
        \bigg\rangle 
  }
  { 
   \Gvdash x_1 : T_1 ~~ \langle E_1 \rangle &&
   \ldots && \Gvdash x_n : T_n ~~ \langle E_n \rangle 
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
% ---------------------------------------------------
% ---------------------- If stmt---------------------
% ---------------------------------------------------
\subsection {If Term}
{\sf if} term takes three arguments, a boolean expression and two statements. Depending on the boolean value being True or False, first or the second statement is executed. The type of the {\sf if} statement is the type of the first and second statement. A correctly typed if term will have these two statements of the same type.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for if,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm if]
  {
    \Gvdash
    {\sf if ~ t_1 ~then~ t_2 ~else ~t_3} : T 
    ~~~ \bigg\langle \exists ~ T_1,T_2,T_3~.~  
                \begin
                  {array}[c]{l} 
                       T_1 = Bool, \\
                       T_2 = T,T_3 = T, \\ 
                       E_1,E_2,E_3
                \end {array}       
        \bigg\rangle 
  }
  { 
   \Gvdash t_1 : T_1 ~~ \langle E_1 \rangle &&
   \Gvdash t_2 : T_2 ~~ \langle E_2 \rangle &&
   \Gvdash t_3 : T_3 ~~ \langle E_3 \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\

% ---------------------------------------------------
% ---------------------- Let -----------------------
% ---------------------------------------------------
\subsection {Let Term}
{\sf let} statment allows the programmer to define local variables and local functions. The local functions are type inferred and added to the symbol table. The scope of these functions is just the {\sf let} term. The representation below assumes that these local functions have already been type inferred and put in the symbol table. All that remains in the where part are local variable definitions.
~~\\~~\\
The type the let statement is the type of the term {\bf t}. The term t is type inferred in the context $\Gamma$ extended with the variables defined in the where part of the let term.
\newpage
\begin{mdframed} [style=MyFrame,userdefinedwidth=16cm,align=center,
                  frametitle=Typing rule for let,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm let]
  {
    \Gvdash \letS 
          {t} 
          {
            \begin{array}[c]{lcl}
              x_1 & = & t_1 \\
              \vdots & \vdots & \vdots \\
              x_m & = & t_m 
            \end{array}          
          }:T 
       ~~~\Bigg\langle 
               \exists  
                      \begin
                        {array}[c]{l}
                        T_0,\ldots,T_m,\\
                        S_1,\ldots,S_m ~~.~
                      \end{array}
                  \begin
                    {array}[c]{l} 
                         T = T_0, \\
                         S_1 = T_1,\ldots,S_m = T_m,\\ 
                         E_0,E_1,\ldots,E_m
                  \end {array}       
          \Bigg\rangle 
  }
  { 
   \begin {array}[c]{l}
   \Gamma \vdash t_m : T_m ~~ \langle E_m \rangle \\
   \hskip 2em \vdots \\ 
   \Gamma \vdash t_1 : T_1 ~~~ \langle E_1 \rangle 
   \end {array} &&
   \begin {array} [c]{l}
   \\~~\\ 
   \Gamma,x_1:S_1,\ldots x_m:S_m \vdash t:T_0 ~~ \langle E_0 \rangle
   \end {array}
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
\section {Generating Type Equations for Patterns}
Patterns are MPL constructs used in defining functions and processes. Function, processes and the let term in MPL have array of pairs of patterns and terms, i.e corresponding to a list of patterns in every row in constructs mentioned above there is a  term or a process command. Before we go ahead and type infer functions and processes, lets write down the typing rules for patterns first.
The different types of patterns for which we will see the typing rules  are as follows.
\begin{itemize}
  \item Variable Pattern
  \item Int Pattern
  \item Double Pattern
  \item Char Pattern
  \item Constructor Pattern
  \item Product Pattern
\end {itemize}

\subsection {Typing rules for patterns}
Since there may be a list of patterns in the constructs where they are used, we will type infer the patterns as a list. Every pattern in the list enhances this context and generates some equations. The final context is used to type infer the term on the right side of the patterns. This is because the final context has all the variables in scope from the patterns on the left.
% ---------------------------------------------------
% ----------------------var pattern------------------
% ---------------------------------------------------
\subsubsection {variable pattern}
The below typing rule is for a list of patterns where variable pattern x is the first pattern followed by the rest of the patterns r.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15.2cm,align=center,
                  frametitle=Typing rule for var pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm varPatt]
  {
    \Gamma \vdash {\sf varPatt ~~ x ~}.~r~:T 
    ~~~ \bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R~.~
           E
          \bigg\rangle
        \bigg\rangle 
  }
  { 
    \Gamma,x:P \vdash \phi ~~~
    \bigg\langle 
        \langle
        \Gamma_1 = x:P,\Gamma
        \rangle ,
        \langle \phi \rangle
    \bigg\rangle &&
    \Gamma_1 \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}
~\\~~\\
% ---------------------------------------------------
% ----------------------Int pattern------------------
% ---------------------------------------------------
\newpage
\subsubsection {int pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for int pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm intPatt]
  {
    \Gamma \vdash {\sf intPatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R ~.~
           T = Int,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Int     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}

% ---------------------------------------------------
% ----------------------double pattern------------------
% ---------------------------------------------------
~~\\~~\\
\subsubsection {double pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for double pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm doublePatt]
  {
    \Gamma \vdash {\sf doublePatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R ~.~
           T = Double,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Double     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}
~~\\~~\\
% ---------------------------------------------------
% ----------------------char pattern------------------
% ---------------------------------------------------

\subsubsection {char pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for char pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm charPatt]
  {
    \Gamma \vdash {\sf charPatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
          \exists R ~.~
           T = Char,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Char     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}


% ---------------------------------------------------
% ---------------------cons pattern------------------
% ---------------------------------------------------
~~\\~~\\
\subsubsection {constructor pattern}
Constructor patterns are made up of constructors of a data type. Let us consider this data type to be D. $C_1$ $\ldots$ $C_m$ are the different constructors and $A_1$, $\ldots$, $A_k$ are the union of type variables used in the different constructors of the data type D. For $C_1$ ,$F_{11}$, $\ldots$, $F_{1a}$ repesent the input type of the constructor.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~data~ D ~\to~ A =
 & ~~ C_1 : F_{11},~ \ldots, ~ F_{1a} \to A \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad \vdots \\ 
 & ~~ C_m : F_{m1} ,~ \ldots, ~ F_{mn} \to A
\end{align*}
The different constructs above are $\alpha$-renamed with fresh variable $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ to avoid any conflict between the variable names used in the the data construct with that used in the equation. The renamed constructs have been represented by adding a superscript $\prime$ to the name of the construct.
\begin{align*}
 & ~~ D^\prime ~~~ = (\Lambda A_1,\ldots,A_k.~ D)~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} 
 \end{align*}
$combEqns$ is a special function used in the typing rule below. This function takes list of type equations as input. The type equation can be of two types.
\begin {itemize}
  \item Type equations with exisential and universal variables.
  \item Type equations without exisential and universal variables.
\end {itemize}

~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for constructor pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm consPatt]
  {
    \begin {array}[c]{l}
    \Gamma \vdash {\sf consPatt ~(C_i,[t_1,\ldots,t_j]~)~}.~r~:T \\ 
    \hskip 3em
        \Bigg\langle 
           \langle \Gamma_r \rangle,
           \bigg\langle
             \exists 
               \begin {array} [c] {l}
                R, \\ 
                A_1^\prime,\ldots A_k^\prime~\\ 
                T_1,\ldots,T_n ~. ~
               \end {array}  
             \begin {array} [c] {l}
                T = D^\prime,\\ 
                T_1 = F_{i1}^\prime ,\ldots,
                T_j = F_{ij}^\prime, \\  
                E_1,E_2,\ldots,E_n,E_r
             \end {array}     
           \bigg\rangle
        \Bigg\rangle 
    \end {array}    
  }
  { 
    \begin {array} [c]{ll}
      \Gamma_{n-1} \vdash t_n:T_n  & 
      \bigg\langle 
          \langle \Gamma_n\rangle,
          \langle E_n \rangle
      \bigg\rangle \\ 
      \hskip 2em \vdots & ~~~ \vdots\\ 
      \Gamma \vdash t_1:T_1 & 
      \bigg\langle 
          \langle \Gamma_1\rangle,
          \langle E_1 \rangle
      \bigg\rangle 
    \end {array} &&
    \begin {array}[c]{l}
       \\~~\\~~\\ 
       \Gamma_n \vdash r :R ~~~ 
          \bigg\langle 
              \langle \Gamma_r\rangle,
              \langle E_r \rangle
          \bigg\rangle 
    \end{array}
  }
\end {mdframed}
% ---------------------------------------------------
% ----------------------prod pattern------------------
% ---------------------------------------------------
~\\~~\\
\newpage
\subsubsection {product pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for product pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm prodPatt]
  {
    \begin {array}[c]{l}
    \Gamma \vdash {\sf (t_1,\ldots,t_n) ~}.~r~:T \\
    \hskip 3em
     \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
             \exists R,T_1,\ldots,T_n.
             \begin {array} [c] {l}
                T = (T_1,T_2,\ldots,T_n) ,\\ 
                E_1,E_2,\ldots,E_n,E_r 
            \end {array}
          \bigg\rangle
        \Bigg\rangle
    \end{array}     
  }
  { 
    \begin {array} [c]{ll}
      \Gamma_{n-1} \vdash t_n:T_n  & 
      \bigg\langle 
          \langle \Gamma_n\rangle,
          \langle E_n \rangle
      \bigg\rangle \\ 
      \hskip 2em \vdots & ~~~ \vdots\\ 
      \Gamma \vdash t_1:T_1 & 
      \bigg\langle 
          \langle \Gamma_1\rangle,
          \langle E_1 \rangle
      \bigg\rangle 
    \end {array} &&
    \begin {array}[c]{l}
       \\~~\\~~\\ 
       \Gamma_n \vdash r:R ~~~ 
          \bigg\langle 
              \langle \Gamma_r\rangle,
              \langle E_r \rangle
          \bigg\rangle 
    \end{array}
  }
\end {mdframed}
~~\\~~\\ 
\newpage 
% ---------------------------------------------------
% ---------------------- Function W/O Types----------
% ---------------------------------------------------
\section {Generating Type Equations for Function Definitions}

\subsection {Function definitions without an annotated type}
These are the function definitions for which the programmer has not annotated the expected type of the function. Once the function defintion is type inferred, the function name is inserted in the symbol table with this type. 

~~\\ 
$combEqns$ function takes a list of type equations and concatenates their universal variables, existential variables and type equations. In the case the list contains a mixture of the two kinds of type equations mentioned above, the resultant type equation will be one type type equation with existential and universal variables. In case all the equations are without variables of either kind, the output list is same as the input list.
~~\\~~\\

~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for function defns with variable patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_1]
  {
    \begin {array}[c]{l}
    \Gvdash
    \fun
      {
        \begin{array}[c]{lcl}
          p_1,\ldots,p_m & \to & t
        \end{array}          
      }:T \\ ~~\\
    \hskip 6em \bigg\langle \exists ~ S_1,\ldots,S_m~.~  
                \begin
                  {array}[c]{l} 
                       T = (S_1,\ldots,S_m)~ \to ~ O,\\
                        E 
                \end {array}       
        \bigg\rangle 
    \end {array}
  }
  { 
  \Gamma \vdash p_1,\ldots,p_m :P ~~ 
  \langle\Gamma_p,E_p \rangle &&
   \Gamma_p \vdash t : O ~~ \langle E \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
Suppose the patterns on the left hand side in the function defintion are constructors of a data type D.  $C_1$ $\ldots$ $C_m$ are the different constructors of the data type D and $A_1$, $\ldots$, $A_k$ are the union of type variables used in the different constructors of the data type.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~data~ D ~\to~ A =
 & ~~ C_1 : F_{11},~ \ldots, ~ F_{1a} \to A \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad \vdots \\ 
 & ~~ C_m : F_{m1} ,~ \ldots, ~ F_{mn} \to A
\end{align*}
$\alpha$ renaming the different constructs in the data D with fresh variables $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ gives the following constructs. 
\begin{align*}
 & ~~ D^{\prime} ~~~ = (\Lambda A_1,\ldots,A_k.~ D)~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime~~ = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} \\
 \end{align*}

\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for function defns with constructor patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_2]
  {
    \begin {array}[c]{l}
      \Gvdash
      \fun
        {
          \begin{array}[c]{lcl}
            C_1 ~ x_{11},\ldots,x_{1a} & \to & t_1 \\ 
            \vdots & \vdots & \vdots \\
            C_m ~ x_{m1},\ldots,x_{mn} & \to & t_m
          \end{array}          
        }:T \\~~\\~~\\   
      \hskip 4em \bigg\langle \exists 
                 \begin {array} [c] {l}
                    ~ S_{11},\ldots,S_{1a} \\
                    \qquad \vdots \qquad \qquad . \\ 
                    ~ S_{m1},\ldots,S_{mn} \\ 
                    ~ T_1,\ldots,T_m,O
                 \end {array}  
                  \begin
                    {array}[c]{l} 
                         T = D^\prime ~ \to ~ O,\\
                         T_1 = O,\ldots,T_m = O,\\ 
                         S_{11} = F_{11}^\prime,\ldots,
                         S_{1a} = F_{1a}^\prime, \\
                         \qquad\qquad \vdots \\ 
                         S_{m1} = F_{m1}^\prime,\ldots,
                         S_{mn} = F_{mn}^\prime, \\
                         E_1,\ldots,E_m
                  \end {array}       
          \bigg\rangle 
    \end {array}
  }
  { 
   \begin {array}[c]{lcl}
     \Gamma,x_{11}:S_{11},~\ldots,~x_{1a}:S_{1a} & \vdash &  t_1 : T_1 ~~~ \langle E_1 \rangle \\
     \hskip 6em \vdots \\ 
     \Gamma,x_{m1}:S_{m1},~\ldots,~x_{mn}:S_{mn} & \vdash &  t_m : T_m ~~\langle E_m \rangle
   \end{array}
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
\subsection {Function defintions with an annotated type}
These are the function definitions for which the programmer has annotated the expected type of the function. Once the function is type inferred, an attempt is made to unify the annotated function type with the inferred one. If the two types can be successfully unified, then the inferred type is line with the expectation of the programmer and the annotated type is inserted in the symbol table with the name of the function.
~~\\~~\\ 
The type equations generated for the annotated functions differ slightly from the unannotated ones. In the interest of succinctness, we will describe the equation generation only for the variable patterns case. Equation generation for the constructor pattern case can be easily extrapolated from this.
~~\\~~\\
Let the annotated function be represented as following.
\begin {align*}
annotatedType = \forall~A_1,\ldots,A_k~.fType
\end {align*}
Renaming the variables $A_1$,$\ldots$,$A_k$ with $A_1^\prime$,$\ldots$,$A_{k}^\prime$ yields the following type.
\begin {align*}
annotatedType^\prime &= (\Lambda A_1,\ldots,A_k~.~annotatedType)~
                   A_1^\prime,\ldots,A_k^\prime \\
                &= \forall~A_1^\prime,\ldots,A_k^\prime~.fType^\prime
\end {align*}
\begin{mdframed} [style=MyFrame,userdefinedwidth=18cm,align=center,
                  frametitle=Typing rule for function defns with variable patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_1]
  {
    \Gvdash
    \funT
      {
       \forall~A_1^\prime,\ldots,A_n^\prime~.fType^\prime
      } 
      {
        \begin{array}[c]{lcl}
          x_1,\ldots,x_m & \to & t
        \end{array}          
      }:T 
    ~~~ \bigg\langle
             \begin {array} [c] {l}
             \forall ~A_1^\prime,\ldots,A_n^\prime \\ 
             \exists ~T \qquad\qquad~~.~ 
             \end {array} 
                \begin
                  {array}[c]{l} 
                       T = fType^\prime,\\
                        E_{fun} 
                \end {array}       
        \bigg\rangle 
  }
  { 
    \Gamma ~\vdash
    \fun
      {
        \begin{array}[c]{lcl}
          x_1,\ldots,x_m & \to & t
        \end{array}          
      }:T ~~ \langle E_{fun} \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\

% ---------------------------------------------------
% ---------------------- default---------------------
% ---------------------------------------------------
\subsection {default term}
{\sf default} term is used as the catch all branch while using guards with the switch statement. The type of the default term is always Bool. 
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=9cm,align=center,
                  frametitle=Typing rule for default,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm default]
  {
   \Gvdash default: T  
    ~~~ \bigg\langle T = Bool 
        \bigg\rangle 
  }
  { 
  }
\end{mdframed}
~~\\~~\\

\end {document}


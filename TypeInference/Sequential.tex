\documentclass[11pt]{article}

\title{Type Inferencing in MPL}
\title{Typing Rules for Sequential MPL}
\usepackage{amsmath }
\usepackage{framed}
\usepackage{proof}
\usepackage{enumerate,xspace,stmaryrd}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{graphicx}
\usepackage{textcomp,xspace}
\usepackage[top=2cm, bottom=2.5cm, right=2.5cm, left=2.5cm]{geometry}
\usepackage{latexsym}  %For plain TeX symbols, such as \Box used in \qed
\usepackage{euscript}  %%Euler Script font
\usepackage {mdframed}
\usepackage{ifpdf}
\ifpdf
  \usepackage{epstopdf}
\fi 
\usepackage{etoolbox}
\BeforeBeginEnvironment{tabular}{\begin{center}\small}
\AfterEndEnvironment{tabular}{\end{center}}


\mdfdefinestyle{MyFrame}{%
    linecolor=black,
    linewidth=1pt
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    leftmargin  = 2cm
    rightmargin = 2cm,
    frametitlealignment = \center
    }

\mdfdefinestyle{MyFrameSp}{%
    linecolor=black,
    linewidth=1pt
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    leftmargin  = .5cm
    rightmargin = .5cm,
    frametitlealignment = \center
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Special symbol macros ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\x}{\times}
\newcommand{\PhiGamma} {\Phi~|~\Gamma}
\newcommand{\Gvdash} {\Gamma \vdash}
\newcommand{\VdashDel} {\Vdash \Delta} 
\newcommand{\ox}{\otimes}
\newcommand{\context}[2]{#1 \left[\hspace{-1.7pt}\left[ #2 \right]\hspace{-1.7pt}\right]}
\newcommand{\bag}[1]{\{\hspace{-2.5pt}[ #1 ]\hspace{-2.5pt}\}}
\newcommand{\cons}{\ensuremath{{\sf cons~}}\xspace}
\newcommand{\dest}{\ensuremath{{\sf dest~}}\xspace}
\newcommand{\get}{\ensuremath{{\sf get ~ x ~\alpha~}}\xspace}
\newcommand{\putC}{\ensuremath{{\sf put ~ x ~\alpha~}}\xspace} 
\newcommand{\close}{\ensuremath{{\sf close ~\alpha~}}\xspace}
\newcommand{\halt}{\ensuremath{{\sf halt ~\alpha~}}\xspace}
\newcommand{\plug}{\ensuremath{{\sf plug ~ (\alpha_1,\ldots,\alpha_n) ~(s_1,s_2)}}\xspace}

\newcommand{\splitC}
    {
     \ensuremath{{\sf split ~~\alpha~~ (\alpha_1,\alpha_2)}}
     \xspace
    }


\newcommand{\fold}[2]{\begin{array}{l}
                        {\sf fold~} #1 \\
                        {\sf ~of~} 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\newcommand{\fork}[2]{\begin{array}{l}
                        {\sf fork~} #1 \\
                        {\sf ~~as~}
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}


\newcommand{\case}[2]{\begin{array}{l}
                        {\sf case~} #1 \\
                        {\sf ~of~} 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\newcommand{\rec}[1]{\begin{array}{l}
                        {\sf rec~} \\
                        {\sf ~of~}
                        \left| \begin{array}{lcl} #1 \end{array} 
                        \right.\end{array}}

\newcommand{\letS}[2]{\begin{array}{l}
                        {\sf let ~} #1 \\
                        {\sf ~where~} \\
                        ~~~\left|\begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}


\newcommand{\fun}[1]{\begin{array}{l}
                        {\sf fun~ f} \\~~ 
                        \left| \begin{array}{lcl} #1 \end{array} 
                        \right.\end{array}}

\newcommand{\funT}[2]{\begin{array}{l}
                        {\sf fun~ f~::~} #1 \\~~ 
                        \left| \begin{array}{lcl} #2 \end{array} 
                        \right.\end{array}}

\begin{document}

\maketitle

\section{Type Inferencing}

\subsection {Introduction}
This chapter deals with the type inference of the various MPL constructs, namely functions, processes, terms and process commands.

\subsection {Type Formation Rules}
Let T be a set of atomic types, $\Omega_{D}$ be a set of type formation symbols for data types and $\omega_{D}$ is a function called arity that describes the number of parameters that the type needs.
\begin{align*}
    \omega_{D} ~ : ~ \Omega_{D} ~ \to ~ \mathbb {N}  
\end{align*}
Similarly, $\omega_{C}$ is the arity function for $\Omega_{C}$ which is a set of set of type formation symbols for codata types.
\begin{align*}
    \omega_{C} ~ : ~ \Omega_{C} ~ \to ~ \mathbb {N}  
\end{align*}
Elements of T can be type variables or type constants like Int, Double and Char. Apart from the atomic types, MPL also has data types, codata types and products as types. Type formation rules describes the rules for the construction of valid types from the elements of T.
~~\\~~\\ 
The type formation rules for MPL are given by the following rules.  
\newpage
\begin{mdframed} [style=MyFrame,userdefinedwidth=12cm,align=center,
                  frametitle=Type Formation Rules,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer []
  {
    A ~~~ type   
  }
  { 
    A \in T
  }
~~\\~~\\
\infer [prod]
  {
    A_1 \times \ldots \times A_n ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type  
  }
~~\\~~\\~~\\ 
\infer [data ~ type]
  {
    D~(A_1 \ldots A_n) ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type  \hskip 2em \omega (D)~ =~ n 
  }
~~\\~~\\~~\\ 
\infer [codata ~ type]
  {
    C~(A_1 \ldots A_n) ~~~ type   
  }
  { 
    A_1~ type && \ldots && A_n ~type \hskip 2em \omega (C)~ =~ n 
  }
\end{mdframed}
~~\\
\subsection {Type Inferencing}
Consider an Algebraic Type System consisting of functions and variables as terms. The term formation rules for the terms are as below.
~~\\~~\\ 
\infer [\rm var]
  {
    \Gamma, x:A \vdash x:A
  }
  { 
  }
~~\\~~\\
\infer [\rm fun]
  {
    \Gamma \vdash ~ f (m_1,\ldots,m_n):B 
  }
  { 
    \Gamma \vdash m_1 : A_1, && \ldots &&
    \Gamma \vdash m_k : A_k && f:A_1,\ldots,A_k \to B \in \Omega  
  }
~~\\~~\\ 
In this type system consider a function,$f(x,y)~ = ~x $ such that
$f:A,B \to A \in \Omega$. Let us try inferring the type of $f~(1,y).$
~~\\~~\\ 
\infer []
  {
   y:B \vdash ~ f (1,y):Int  
  }
  { 
    y:B \vdash y:B && y:B \vdash 1:Int 
    && f:A ,B \to A \in \Omega    
  }
~~\\~~\\ 
Please note that $f:Int,B \to Int$ is a more specific type than the type of $f$ initially assigned in $\Omega$. The new more specific type of $f$ is consistent with its original more generic type. However, this way of type inferencing while suitable for calculation by hand doesn't lend itself well to automation. For this reason, the typing rules are enhanced with equations that capture the constraint relationship between the different parts of the construct being type inferred.
~~\\~~\\ 
\infer [\rm var]
  {
    \Gamma, x:A \vdash x:B ~~ \big\langle A = B \big\rangle
  }
  { 
  }
~~\\~~\\
\infer [\rm fun]
  {
    \Gamma \vdash ~ f (m_1,\ldots,m_n):C 
    ~~\big\langle B = C,A_1 = A_1^\prime,\ldots,A_k = A_k^\prime \big\rangle
  }
  { 
    \Gamma \vdash m_1 : A_1^\prime, && \ldots &&
    \Gamma \vdash m_k : A_k^\prime && f:A_1,\ldots,A_k \to B \in \Omega  
  }
~~\\~~\\
Now consider type inferring the function $ f(1,y)$ in this setup.
~~\\~~\\
\infer []
  {
   y:B \vdash ~ f (1,y):Int  
   ~~~\big\langle 
      A^\prime = Int,~B^\prime = B,~A = Int 
   \big\rangle
  }
  { 
    y:B \vdash y:B^\prime && y:B \vdash 1:Int 
    && f:A^\prime,B^\prime \to A \in \Omega    
  }
~~\\~~\\ 
Once the type equations are solved by relacing the value of $A,B$ and $A^\prime$ in function type of $f$, $Int,B \to Int $ is obtained. This is the type of function $f$.
~~\\~~\\ 
The type inference has been broken down into two mechanical steps, namely {\em Generation of Type Equations} and {\em Solving Type Equations}. The mechanical and algorithmic nature of this presentation is useful when implementing type systems on a computer.  
~~\\~~\\
One drawback of the equational presentation of the type systems mentioned in the previous paragraph is that one ends up with a big linear list of equations. Solving this list of equations maybe slow as one needs to go through the entire list every time in order to look for substitutions.
~~\\~~\\
In this thesis, we have modified this presentation to take advantage of the structure of the {\em type inference tree} when searching for substitutions. In this approach, the algorithm only searches the part of the type inference tree which could have generated these substitutions. Thus our algorithm localises the substitution search leading to faster soltuion of type equations. Our algorithm also has an added advantage of localising the type errors. This results in better location accuracy when reporting the type errors.
~~\\~~\\ 
Consider a function $f(a,b)$ such that $ f:~A,B \to C \in \Omega $ and one needs to type infer $f(x+y,z)$ in our setup. In the below {\em type inference tree}, the context x:X,y:Y,z:Z has been replaced with symbol $\Gamma$ for the purpose of succinct representation. 

~~\\~~\\
\infer []
  {
   \Gamma \vdash ~ f (x+y,z):A  
   ~~~\big\langle 
      A^\prime = Int,~B^\prime = B,~A = Int 
   \big\rangle
  }
  { 
    \infer []
     {
      \Gamma \vdash x + y ~:C
     } 
     {
       \infer []
       {
        \Gamma \vdash x:D
       }
       {
       }
        && 
       \infer []
       {
        \Gamma \vdash y:E
       }
       {
       }
     } 
      && \infer []
           {\Gamma \vdash  z:B} 
           {}
      &&f:P~,Q \to R \in \Omega 
  }


\subsection {Overview of Type Inference of MPL Constructs}
Type inference involves two main steps. 
\begin {itemize}
\item {\bf Generating Type Equations} - Type Equations represent the constraint relationship between the different parts of the construct being type inferred. 
~~\\~~\\
Using the typing rules, a series of equations are generated in the proof search direction. The equation structure hierarchical following the shape of the type inference tree. Thus, the placement of an equation inside a type equation depends on thes the location within a type inference tree that resulted in that equation within the type equation. This approach allows hierarchical solution of type equations and better localisation of type errors.     
\item {\bf Solving Type Equations} - The type equations are solved in order to get the most general type of a given program.
\end{itemize}
In this chapter, the generation fo type equations for the Sequential MPL (terms and functions) is dicussed followed by the generation of type equation for Concurrent MPL. Finally, we look at an algorithm to solve the type equations to get the most general type.

\section {Generating Type Equations for Sequential Terms }
Here the type inference rules for the various sequential MPL constructs are dicussed. The type inference rules can be thought of as term formation rules enhanced with the typing information of the constituting terms.
\subsection {Variable Term}
% ---------------------------------------------------
% ---------------------- Var -----------------------
% ---------------------------------------------------
In order to infer a variable which is a sequential term,the variable should be looked up in the context. If it is present in the context, then the type variable corresponding to the var term should be equated with the variable type from the context.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=8cm,align=center,
                  frametitle=Typing rule for variable ,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm id]
  {
    x:P , \Gamma \vdash x : Q  
    ~~~ \bigg\langle P = Q 
        \bigg\rangle 
  }
  { 
  }
\end{mdframed}
~~\\~~\\
% ---------------------------------------------------
% ----------------------call-------------------------
% ---------------------------------------------------
\subsection {Function Call}
Let $\Omega$ be a set of function symbols and $T_y$ be a type. $\sigma$ is a function of the below type that returns as output the the input and output types of a function symbol.
~~\\~~\\
$sigma$ is defined both for inbuilt functions as well user defined functions.
Example of $\sigma$ for inbuilt functions is below. 
\begin{align*}
    & \sigma (+_{Int}) ~~ = ~~ ([Int,Int],Int) ~~\\ 
    & \sigma ('s') ~~~~~ = ~~ ([~],Char)
\end{align*}
Consider a user defined function factorial which takes an integer as the input and outputs the factorial of the integer. The type of the output is also an integer. $\sigma$ for factorial is defined below.
\begin{align*}
    & \sigma (fact) ~~ = ~~ ([Int],Int)  
\end{align*}
Consider a function f taking m inputs of types $S_1$, $\ldots$ $S_m$. The output type of the function is S. 
\begin{align*} 
 & f:\forall A_1,~ \ldots,~A_k.~S_1,\ldots,S_m \to S 
\end{align*}
The output and input types are $\alpha$-renamed before using these constructs in the type equations. This is done to avoid any name clashes between the variables of the function and the variables already used in the equation.
\begin{align*}
 & ~~ S_{i}^\prime = (\Lambda A_1,\ldots,A_k.~S_i)~A_1^{\prime},\ldots,A_k^{\prime} ~~~ \{~ 1~ \leq~ i~ \leq m\} \\
 & ~~ S^{\prime} = (\Lambda A_1,\ldots,A_k.~ S)~A_1^{\prime},\ldots,A_k^{\prime} 
 \end{align*}
\begin{itemize}
   \item The type of a function call is the output type of the function type of the function being called.
   \item The type of the various input arguments of the function call can be  deduced from the input types of the function type of the function being called.
 \end{itemize} 
 \begin{mdframed} [style=MyFrameSp,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for function call,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
{\small
\infer [\rm call]
  {
    \Gamma \vdash {\sf f ~(t_1,\ldots,t_m)}
   : T  ~~
       \Bigg\langle 
                \exists \,
                \begin
                  {array}[c]{l}
                  A_1^{\prime},\ldots,A_k^{\prime},\\
                  T_1,\ldots,T_m ~~.~
                \end{array}
                \begin {array}[c]{l} 
                   T = S^{\prime},\\
                   T_1 = S_{1}^\prime,\ldots,T_m = S_{m}^\prime ,\\
                   E_1,\ldots,E_m
                \end{array} 
            \Bigg\rangle 
  }
  { \Gvdash  t_1 : T_1 ~~\langle E_1 \rangle && \ldots &&
    \Gvdash  t_n : T_n ~~\langle E_n \rangle 
  }
}  
\end{mdframed}

~~\\~~\\

% ---------------------------------------------------
% ---------------------- Constants-------------------
% ---------------------------------------------------
\subsection {Constant Term}
{\sf constants} can be one of the built in constant types, like int, double and char.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=10cm,align=center,
                  frametitle=Typing rule for constants,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\
\infer [\rm int]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Int 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n:Int
  }~~\\~~\\

\infer [\rm double]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Double 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n : Double
  }~~\\~~\\

\infer [\rm char]
  {
    \Gamma \vdash ~n : T  
    ~~~ \bigg\langle T = Char 
        \bigg\rangle 
  }
  { 
    \Gamma \vdash n : Char
  }

\end{mdframed}
% ---------------------------------------------------
% ---------Constructor/Destructor--------------------
% ---------------------------------------------------
~~\\~~\\
\subsection {Case and Constructor Term}
{\sf constructor } term creates a data type with the constructors of that data type.
~~\\~~\\
{\sf case} term branches on the different constructors of a data type. Every branch consists of a constructor and a term as can be seen from the case syntax on page ~ \pageref{caseLab}. The term is executed when the corresponding constructor is selected. 
\subsubsection {Data Type Declaration}\label{dataDef}
Consider a data type D($A_1$, $\ldots$, $A_k$) having constructors $C_1$ $\ldots$ $C_m$ defined below: 
\begin{align*} 
~data~ D(A_1,\ldots,A_k)  ~\to~ Z =
 & ~~ C_1 : T_{11},\ldots, T_{1a} ~~~~~\to ~~~ Z \\
 & ~~~~ \vdots \hskip 4em \vdots \hskip 4.5em \vdots \\ 
 & ~~ C_m : T_{m1},\ldots, T_{mn} ~~\to ~~~ Z
\end{align*}
In the data type definition above:
\begin{itemize}
  \item The data type D ($A_1$, $\ldots$, $A_k$) is polymorphic in type variables $A_1$, $\ldots$, $A_k$ which means that $A_1$, $\ldots$, $A_k$ are the union of type variables used in the different constructors of the data type.
  \item Constructor $C_1$ takes {\bf ``a''} number of input terms of types $\mathbf{T_{11},\ldots,T_{1a}}$ respectively.
  \item $\mathbf{T_{ij}}$ is a type expression such that:
\begin{align*}
TypeVar~(F_{ij})~~\subseteq~~ \{Z,A_1,\ldots,A_k\}
\end{align*}
\item For a constructor $\mathbf{C_f}$ of data type $\mathbf{D}$ which takes {\bf ``g''} number of inputs:
\begin{itemize}
  \item the type of the {\sf fold} is directly given by the type expression corresponding to that constructor in the data definition which is:
  \begin{align*}
    T_{f1},\ldots,T_{fg}~\to~Z
  \end{align*}
  \item the type of the constructor $\mathbf{C_f}$ is given by:
  \begin{align*}
    (F_{f1},\ldots,F_{fg}~\to~Z)~~\Big[D(A_1,\ldots,A_k)/Z\Big]
  \end{align*}
  The above representation means that in the type expression $\mathbf{F_{f1},\ldots,F_{fg}~\to~A}$, the type variable $\mathbf{A}$ is substituted with $\mathbf{D(A_1,\ldots,A_k)}$.
\end{itemize}
\end{itemize}
Before proceeding with the type inference of the data type constructs, the data type definition is $\alpha$-renamed with fresh variables $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ to avoid any naming conflicts when these constructs are used in type equations. For the same reason, the $\alpha$-renaming technique is used with non-data type constructs as well.
~~\\~~\\ 
The below representation means that in the type expression $\mathbf{T_1}$, the type variables $\mathbf{Z,A_1,\ldots,A_k}$ have been replaced with fresh variables $\mathbf{Z^\prime,A_1^\prime,\ldots,A_k^\prime}$ respectively.
\begin{align*}
T_{ij}~[Z/Z^\prime,A_1/A_1^{\prime},\ldots,A_k^{\prime}]
\end{align*}
$\mathbf{\Lambda_d}$ is a function that takes as arguments a data type, the list of old variables present in that data type and a fresh variables list to replace the old variables. The output of this function is a data type where the old variables in its body have been replaced by the new variables.
\begin{align*}
& \Lambda_d ::~[Type~~Vars],~Type,~[Type~~Vars]~\to~Type 
\end{align*}
The renamed parts of the data definition have been represented by adding superscript prime $(\mathbf{\prime})$ to their names as shown below:
\begin{align*}
& D^\prime(A_1^{\prime},\ldots,A_k^{\prime}) ~ = (\Lambda A_1,\ldots,A_k.~ D(A_1,\ldots,A_k))~A_1^{\prime},\ldots,A_k^{\prime}\\
& F_{xy}^\prime = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} 
\end{align*}
\subsubsection {Type Equations for Case and Constructor Term} 
The function type of a constructor can be looked up from the symbol table.
\begin{itemize}
  \item The output type of the {\sf constructor} term is the output type of the function for that constructor looked up from the symbol table. 
  \item The types of the various arguments of the constructor are the corresponding input types  for that constructor looked up from its function type from the symbol table.
  \item $E_1$, $\ldots$, $E_j$ are the type equations generated for the terms $t_1$, $\ldots$, $t_j$ respectively.
\end{itemize}
~~\\
The type of a {\sf case} term is the type of the terms on the right side of the branches. A well typed case term will have same type for all the terms on the right side of the branches. The types of the input arguments for a constructor on the left hand side of a branch is obtained by looking up the function type for that constructor from the symbol table. 

% ---------------------------------------------------
% ---------------------- Fold -----------------------
% ---------------------------------------------------
\subsection {Fold Term}
{\sf fold} is used to implement higher order primitive recursive functions which gurantees termination. Like case, fold also has branches corresponding to every constructor of the data type over which one is folding. Every branch has some argument on the left side of the arrow and a term on the right side as can be seen in the fold syntax on page \pageref{foldLab}. 
\begin{table}
\begin{center}
\begin{tabular}{|c|} \hline
{\bf Typing Rule for constructor,case and fold term}  \\ 
\hline\\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm cons]
  { 
    \begin {array} [c]{l}  
        \Gamma \vdash \cons (C_i,[t_{1},\ldots,t_j]):T 
        \hskip 1em
        \left\langle
            \exists \,
            \begin
              {array}[c]{l}
              T_1,\ldots,T_j, \\
              A_1,\ldots,A_n .
            \end{array}
            \begin
              {array}[c]{l} T = D^{\prime}\\
              T_1 = F_{i1}^\prime,\,\ldots,\,T_j = F_{ij}^\prime\\
              E_1,E_2,\ldots,E_j
            \end{array} 
        \right\rangle
    \end {array}
  } 
  { \Gamma \vdash t_1:T_1 ~~~\langle E_1 \rangle && \ldots && ~~~
    \Gamma \vdash t_j:T_j ~~~\langle E_j \rangle
  }
}
\end {minipage} \\~~\\ \hline \hline \\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm case]{
      \begin {array} [c] {l}
         \Gamma \vdash 
         \case {t} 
          {
            \begin{array}[c]{lcl}
              {C_1~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {C_m~x_{m1},\ldots,x_{mn}} & \to & t_n 
            \end{array}          
          }:T~~ \Biggl\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_0,T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T_0 = D^\prime(A_1^\prime,\ldots,A_k^\prime),\\
                  T_1 = T,\ldots,T_m = T\\
                  T_{11}= F_{11}^\prime,\ldots,T_{11}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Biggr\rangle
      \end {array}    
       }
       {
         \Gamma \vdash t:T_0 ~ \langle E_0 \rangle &&
         \begin {array}[c]{lcll} 
             \Gamma,x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
             & \langle E_m \rangle \\
             \hskip 10em \vdots\\ 
             \Gamma,x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
             & \langle E_1 \rangle 
         \end{array} 
       }~~\\~~\\  
}
\end {minipage} 
 \\~~\\ \hline \hline \\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm fold] {
    \begin {array}[c]{l}
         \Gamma \vdash 
         \fold {t} 
          {
            \begin{array}[c]{lcl}
              {C_1~:~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {C_m~:~x_{m1},\ldots,x_{mn}} & \to & t_n 
            \end{array}          
          }:T~~ \Bigg\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_0,T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T_0 = D^\prime\\ 
                  T_1 = T,\ldots,T_m = T\\
                  T_{11}= F_{11}^\prime,\ldots,T_{11}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Bigg\rangle 
    \end {array} 
       }
       {
         \begin {array}[c]{l}
             \\~~\\
             t:T_0 ~ \langle E_0 \rangle 
         \end {array} && 
             \begin {array} [c] {lcll}             
                 x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
                 & \langle E_m \rangle \\
                 \hskip 10em \vdots \\  
                 x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
                 & \langle E_1 \rangle 
             \end {array}
       }
}
\end {minipage} 
\tabularnewline
\hline
\end{tabular}
\caption{Typing Rules : constructor, case and fold terms}
\label{STypeInf:DataTermsRules}
\end{center}
\end{table}

~~\\~~\\
For all the constructors of a data type, their fold functions are  inserted in the symbol table. We will use the data definition for D($A_1$, $\ldots$, $A_k$) and the renamed constructs from the section \ref{dataDef} on page \pageref{dataDef}
~~\\~~\\
The type of a {\sf fold} term is the type of the terms on the right side of the branches. In a well typed {\sf fold} term, all the terms on the right side of the branches will have same type. The types of the input arguments for a given constructor on the left hand side of a branch is obtained by looking up the fold function type for that constructor from the symbol table. 
% ---------------------------------------------------
% -----------------------Record----------------------
% ---------------------------------------------------
\subsection {Record and Destructor Term}
{\sf record } term forms a record for a codata type. {\sf dest} destructs a record of a codata type with a particular destuctor of that codata type.It obtains the term corresponding to that destructor from the record.
\subsubsection {Codata Type Declaration}
Consider the codata declaration for a codata type C$(A_1,\ldots,A_k)$. $D_1$, $\ldots$, $D_m$ are the different destructors of the codata type. C$(A_1,\ldots,A_k)$  is polymorphic in type variables $A_1,\ldots,A_k$ which means that $A_1,
\ldots,A_k$ are the type variables used in the different destructors of the codata type. For destructor $D_1$ which takes {\bf ``a''} number of input terms , $F_{11}$, $\ldots$, $F_{1a}$ repesent the types of the input terms.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~codata~ A ~\to~ C (A_1,\ldots,A_k) =
 & ~~ D_1 : F_{11},~ \ldots, ~ F_{1a},~A \to P_1 \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad\qquad \vdots \\ 
 & ~~ D_m : F_{m1} ,~ \ldots, ~ F_{mn},~A \to P_m
\end{align*}
Renaming the different constructs in the codata C$(A_1,\ldots,A_k)$ with fresh variables $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ gives the following constructs. 
\begin{align*}
 & ~~ C^{\prime}(A_1^\prime,\ldots,A_k^\prime)~ = ~(\Lambda A_1,\ldots,A_k.~ C (A_1,\ldots,A_k))~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime ~ =~ (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} \\
 & ~~ P_{i}^\prime ~~~=~ (\Lambda A_1,\ldots,A_k.~ P_i)~A_1^{\prime},\ldots,A_k^{\prime} 
  ~~~~~ \{ 1 \leq i \leq m \} \\
 \end{align*}
\subsubsection {Type Equations for Record and Destructor Term}

The type of a {\sf record} of a codata type is that codata type.
~~\\~~\\ 
The function type of a destructor can be looked up from the symbol table. Following details about the type of destructor can be obtained from its function type.
\begin{itemize}
  \item if a destructor takes n arguments, then the corresponding function type of the destructor will have (n+1) input types. The first n types out of the (n+1) types are the types of the corresponding arguments. The $(n+1)^{th}$ type is the codata type of the destructor.
  \item The output type of the destructor is the output type of the function for that destructor looked up from the symbol table.    
\end{itemize}

\begin{table}
\begin{center}
\begin{tabular}{|c|} \hline
{\bf Typing Rules for destructor, record, product and unfold term}  \\ 
\hline\\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm rec] {
    \begin {array}[c]{l}      
         \Gamma \vdash 
         \rec 
          {
            \begin{array}[c]{lcl}
              {D_1~x_{11},\ldots,x_{1a}} & \to & t_1 \\
              \vdots & \vdots & \vdots \\
              {D_m~x_{m1},\ldots,x_{mn}} & \to & t_m 
            \end{array}          
          }:T ~~~\Bigg\langle
                \exists \,
                \begin
                  {array}[c]{l}
                  T_1,\ldots,T_m, \\
                  T_{11},\ldots,T_{1a},\\
                  \qquad \vdots \qquad\qquad .\\
                  T_{m1},\ldots,T_{mn},\\
                  A_1^{\prime},\ldots,A_k^{\prime} 
                \end{array}
                \begin
                  {array}[c]{l} 
                  T = C^\prime(A_1^\prime,\ldots,A_k^\prime)\\
                  T_1 = P_1^\prime,\ldots,T_m = P_m^\prime\\
                  T_{11}= F_{11}^\prime,\ldots,T_{1a}= F_{1a}^\prime\\
                  \qquad\qquad \vdots \\
                  T_{m1}= F_{m1}^\prime,\ldots,T_{mn}= F_{mn}^\prime\\
                  E_1,E_2,\ldots,E_m
                \end{array} 
            \Bigg\rangle  
    \end {array}
       }
       {
         \begin {array}[c]{lcll}
         x_{11}:T_{11},\ldots,x_{1a}:T_{1a} & \vdash & t_1 : T_1
         & \langle E_1 \rangle \\ 
         \hskip 8em \vdots & & \vdots \\ 
         x_{m1}:T_{m1},\ldots,x_{mn}:T_{mn} & \vdash & t_m : T_m
         & \langle E_m \rangle
         \end {array}
       }
}  
\end {minipage} \\~~\\ \hline \hline \\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm prod]
  {
    \Gvdash (x_1,\ldots,x_n) : T 
    ~~~ \bigg\langle \exists ~ T_1,\ldots,T_n~.~  
                \begin
                  {array}[c]{l} 
                       T = (T_1,\ldots,T_n) \\ 
                       ,E_1,\ldots,E_n
                \end {array}       
        \bigg\rangle 
  }
  { 
   \Gvdash x_1 : T_1 ~~ \langle E_1 \rangle &&
   \ldots && \Gvdash x_n : T_n ~~ \langle E_n \rangle 
  }
}
\end {minipage} 
 \\~~\\ \hline \hline \\~~\\
\begin{minipage}{6.5in}
{
\infer [\rm dest]
  { 
   \begin {array}[c]{l}
    {
      \Gamma \vdash \dest (D_i,[t_{i1},\ldots,t_{ij}])
             ~~\Bigg(
             \rec 
              {
                \begin{array}[c]{lcl}
                  \vdots & \vdots & \vdots \\
                  {D_i~x_{i1},\ldots,x_{ij}} & \to & t_i \\
                  \vdots & \vdots & \vdots \\
                \end{array}          
              }\Bigg):T   
    }\\~~\\
    {
      \hskip 16em \Bigg\langle
          \exists \,
          \begin
            {array}[c]{l}
            T_0,T_1,\ldots,T_j, \\
            A_1^{\prime},\ldots,A_n^{\prime}~~~~ .
          \end{array}
          \begin
            {array}[c]{l} 
            T = T_0,\\ 
            T_0 = P_{i}^\prime,\\
            T_1 = S_1,\ldots,T_j = S_j\\
            S_1 = F_{i1}^\prime,\ldots,S_j = F_{ij}^\prime,\\
            E_0,E_1,\ldots,E_j
          \end{array} 
      \Bigg\rangle 
    }
    \end{array}  
  } 
  { 
    \begin {array} [c] {l}
    \Gamma \vdash t_{i1}:T_1 ~~~\langle E_{i1} \rangle \\ 
    \hskip 5em \vdots \\ 
    \Gamma \vdash t_{ij}:T_j ~~~\langle E_{ij} \rangle 
    \end {array} &&
    \begin {array}[c]{l}
      \\~~\\
      \Gamma, x_{i1}:S_1,\ldots,x_{ij}:S_j \vdash t_i:T_0 
      ~~~ \langle E_0 \rangle
    \end {array}
  }~~\\ 
}
\end {minipage} 
\tabularnewline
\hline
\end{tabular}
\caption{Typing Rules : destructor, record, product and unfold terms}
\label{STypeInf:CodataTermsRules}
\end{center}
\end{table}



% ---------------------------------------------------
% ---------------------- Prod -----------------------
% ---------------------------------------------------
\subsection {Product Term}
{\sf prod} term is used to represent tuples in MPL. The output type of a tuple is the product of the types of the individual elements.

% ---------------------------------------------------
% ---------------------- If stmt---------------------
% ---------------------------------------------------
\subsection {If Term}
{\sf if} term has three arguments, a boolean expression and two statements. Depending on the boolean value being True or False, first or the second statement is executed. The type of the {\sf if} statement is the type of the first and second statement. A correctly typed if term will have these two statements of the same type.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for if,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm if]
  {
    \Gvdash
    {\sf if ~ t_1 ~then~ t_2 ~else ~t_3} : T 
    ~~~ \bigg\langle \exists ~ T_1,T_2,T_3~.~  
                \begin
                  {array}[c]{l} 
                       T_1 = Bool, \\
                       T_2 = T,T_3 = T, \\ 
                       E_1,E_2,E_3
                \end {array}       
        \bigg\rangle 
  }
  { 
   \Gvdash t_1 : T_1 ~~ \langle E_1 \rangle &&
   \Gvdash t_2 : T_2 ~~ \langle E_2 \rangle &&
   \Gvdash t_3 : T_3 ~~ \langle E_3 \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\

% ---------------------------------------------------
% ---------------------- Let -----------------------
% ---------------------------------------------------
\subsection {Let Term}
{\sf let} statment allows the programmer to define local variables and local functions. The local functions are type inferred and added to the symbol table. The scope of these functions is just the {\sf let} term. The representation below assumes that these local functions have already been type inferred and put in the symbol table. All that remains in the where part are local variable definitions.
~~\\~~\\
The type the let statement is the type of the term {\bf t}. The term t is type inferred in the context $\Gamma$ extended with the variables defined in the where part of the let term.
\newpage
\begin{mdframed} [style=MyFrame,userdefinedwidth=16cm,align=center,
                  frametitle=Typing rule for let,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm let]
  {
    \Gvdash \letS 
          {t} 
          {
            \begin{array}[c]{lcl}
              x_1 & = & t_1 \\
              \vdots & \vdots & \vdots \\
              x_m & = & t_m 
            \end{array}          
          }:T 
       ~~~\Bigg\langle 
               \exists  
                      \begin
                        {array}[c]{l}
                        T_0,\ldots,T_m,\\
                        S_1,\ldots,S_m ~~.~
                      \end{array}
                  \begin
                    {array}[c]{l} 
                         T = T_0, \\
                         S_1 = T_1,\ldots,S_m = T_m,\\ 
                         E_0,E_1,\ldots,E_m
                  \end {array}       
          \Bigg\rangle 
  }
  { 
   \begin {array}[c]{l}
   \Gamma \vdash t_m : T_m ~~ \langle E_m \rangle \\
   \hskip 2em \vdots \\ 
   \Gamma \vdash t_1 : T_1 ~~~ \langle E_1 \rangle 
   \end {array} &&
   \begin {array} [c]{l}
   \\~~\\ 
   \Gamma,x_1:S_1,\ldots x_m:S_m \vdash t:T_0 ~~ \langle E_0 \rangle
   \end {array}
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
\section {Generating Type Equations for Patterns}
Patterns are MPL constructs used in defining functions and processes. Function, processes and the let term in MPL have array of pairs of patterns and terms, i.e corresponding to a list of patterns in every row in constructs mentioned above there is a  term or a process command. Before we go ahead and type infer functions and processes, lets write down the typing rules for patterns first.
The different types of patterns for which we will see the typing rules  are as follows.
\begin{itemize}
  \item Variable Pattern
  \item Int Pattern
  \item Double Pattern
  \item Char Pattern
  \item Constructor Pattern
  \item Product Pattern
\end {itemize}

\subsection {Typing rules for patterns}
Since there may be a list of patterns in the constructs where they are used, we will type infer the patterns as a list. Every pattern in the list enhances this context and generates some equations. The final context is used to type infer the term on the right side of the patterns. This is because the final context has all the variables in scope from the patterns on the left.
% ---------------------------------------------------
% ----------------------var pattern------------------
% ---------------------------------------------------
\subsubsection {variable pattern}
The below typing rule is for a list of patterns where variable pattern x is the first pattern followed by the rest of the patterns r.
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15.2cm,align=center,
                  frametitle=Typing rule for var pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm varPatt]
  {
    \Gamma \vdash {\sf varPatt ~~ x ~}.~r~:T 
    ~~~ \bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R~.~
           E
          \bigg\rangle
        \bigg\rangle 
  }
  { 
    \Gamma,x:P \vdash \phi ~~~
    \bigg\langle 
        \langle
        \Gamma_1 = x:P,\Gamma
        \rangle ,
        \langle \phi \rangle
    \bigg\rangle &&
    \Gamma_1 \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}
~\\~~\\
% ---------------------------------------------------
% ----------------------Int pattern------------------
% ---------------------------------------------------
\newpage
\subsubsection {int pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for int pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm intPatt]
  {
    \Gamma \vdash {\sf intPatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R ~.~
           T = Int,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Int     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}

% ---------------------------------------------------
% ----------------------double pattern------------------
% ---------------------------------------------------
~~\\~~\\
\subsubsection {double pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for double pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm doublePatt]
  {
    \Gamma \vdash {\sf doublePatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
           \exists R ~.~
           T = Double,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Double     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}
~~\\~~\\
% ---------------------------------------------------
% ----------------------char pattern------------------
% ---------------------------------------------------

\subsubsection {char pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for char pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm charPatt]
  {
    \Gamma \vdash {\sf charPatt ~~ n ~}.~r~:T 
    ~~~ \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
          \exists R ~.~
           T = Char,~~
           E
          \bigg\rangle
        \Bigg\rangle 
  }
  { 
    n:Char     &&&&
    \Gamma \vdash r : R  ~~~
    \bigg\langle 
       \langle
         \Gamma_f
       \rangle,
       \langle E \rangle
    \bigg\rangle
  }
\end {mdframed}


% ---------------------------------------------------
% ---------------------cons pattern------------------
% ---------------------------------------------------
~~\\~~\\
\subsubsection {constructor pattern}
Constructor patterns are made up of constructors of a data type. Let us consider this data type to be D. $C_1$ $\ldots$ $C_m$ are the different constructors and $A_1$, $\ldots$, $A_k$ are the union of type variables used in the different constructors of the data type D. For $C_1$ ,$F_{11}$, $\ldots$, $F_{1a}$ repesent the input type of the constructor.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~data~ D ~\to~ A =
 & ~~ C_1 : F_{11},~ \ldots, ~ F_{1a} \to A \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad \vdots \\ 
 & ~~ C_m : F_{m1} ,~ \ldots, ~ F_{mn} \to A
\end{align*}
The different constructs above are $\alpha$-renamed with fresh variable $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ to avoid any conflict between the variable names used in the the data construct with that used in the equation. The renamed constructs have been represented by adding a superscript $\prime$ to the name of the construct.
\begin{align*}
 & ~~ D^\prime ~~~ = (\Lambda A_1,\ldots,A_k.~ D)~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} 
 \end{align*}
$combEqns$ is a special function used in the typing rule below. This function takes list of type equations as input. The type equation can be of two types.
\begin {itemize}
  \item Type equations with exisential and universal variables.
  \item Type equations without exisential and universal variables.
\end {itemize}

~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for constructor pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm consPatt]
  {
    \begin {array}[c]{l}
    \Gamma \vdash {\sf consPatt ~(C_i,[t_1,\ldots,t_j]~)~}.~r~:T \\ 
    \hskip 3em
        \Bigg\langle 
           \langle \Gamma_r \rangle,
           \bigg\langle
             \exists 
               \begin {array} [c] {l}
                R, \\ 
                A_1^\prime,\ldots A_k^\prime~\\ 
                T_1,\ldots,T_n ~. ~
               \end {array}  
             \begin {array} [c] {l}
                T = D^\prime,\\ 
                T_1 = F_{i1}^\prime ,\ldots,
                T_j = F_{ij}^\prime, \\  
                E_1,E_2,\ldots,E_n,E_r
             \end {array}     
           \bigg\rangle
        \Bigg\rangle 
    \end {array}    
  }
  { 
    \begin {array} [c]{ll}
      \Gamma_{n-1} \vdash t_n:T_n  & 
      \bigg\langle 
          \langle \Gamma_n\rangle,
          \langle E_n \rangle
      \bigg\rangle \\ 
      \hskip 2em \vdots & ~~~ \vdots\\ 
      \Gamma \vdash t_1:T_1 & 
      \bigg\langle 
          \langle \Gamma_1\rangle,
          \langle E_1 \rangle
      \bigg\rangle 
    \end {array} &&
    \begin {array}[c]{l}
       \\~~\\~~\\ 
       \Gamma_n \vdash r :R ~~~ 
          \bigg\langle 
              \langle \Gamma_r\rangle,
              \langle E_r \rangle
          \bigg\rangle 
    \end{array}
  }
\end {mdframed}
% ---------------------------------------------------
% ----------------------prod pattern------------------
% ---------------------------------------------------
~\\~~\\
\newpage
\subsubsection {product pattern}
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for product pattern,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
\infer [\rm prodPatt]
  {
    \begin {array}[c]{l}
    \Gamma \vdash {\sf (t_1,\ldots,t_n) ~}.~r~:T \\
    \hskip 3em
     \Bigg\langle
          \langle
             \Gamma_f
          \rangle,
          \bigg\langle
             \exists R,T_1,\ldots,T_n.
             \begin {array} [c] {l}
                T = (T_1,T_2,\ldots,T_n) ,\\ 
                E_1,E_2,\ldots,E_n,E_r 
            \end {array}
          \bigg\rangle
        \Bigg\rangle
    \end{array}     
  }
  { 
    \begin {array} [c]{ll}
      \Gamma_{n-1} \vdash t_n:T_n  & 
      \bigg\langle 
          \langle \Gamma_n\rangle,
          \langle E_n \rangle
      \bigg\rangle \\ 
      \hskip 2em \vdots & ~~~ \vdots\\ 
      \Gamma \vdash t_1:T_1 & 
      \bigg\langle 
          \langle \Gamma_1\rangle,
          \langle E_1 \rangle
      \bigg\rangle 
    \end {array} &&
    \begin {array}[c]{l}
       \\~~\\~~\\ 
       \Gamma_n \vdash r:R ~~~ 
          \bigg\langle 
              \langle \Gamma_r\rangle,
              \langle E_r \rangle
          \bigg\rangle 
    \end{array}
  }
\end {mdframed}
~~\\~~\\ 
\newpage 
% ---------------------------------------------------
% ---------------------- Function W/O Types----------
% ---------------------------------------------------
\section {Generating Type Equations for Function Definitions}

\subsection {Function definitions without an annotated type}
These are the function definitions for which the programmer has not annotated the expected type of the function. Once the function defintion is type inferred, the function name is inserted in the symbol table with this type. 

~~\\ 
$combEqns$ function takes a list of type equations and concatenates their universal variables, existential variables and type equations. In the case the list contains a mixture of the two kinds of type equations mentioned above, the resultant type equation will be one type type equation with existential and universal variables. In case all the equations are without variables of either kind, the output list is same as the input list.
~~\\~~\\

~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=14cm,align=center,
                  frametitle=Typing rule for function defns with variable patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_1]
  {
    \begin {array}[c]{l}
    \Gvdash
    \fun
      {
        \begin{array}[c]{lcl}
          p_1,\ldots,p_m & \to & t
        \end{array}          
      }:T \\ ~~\\
    \hskip 6em \bigg\langle \exists ~ S_1,\ldots,S_m~.~  
                \begin
                  {array}[c]{l} 
                       T = (S_1,\ldots,S_m)~ \to ~ O,\\
                        E 
                \end {array}       
        \bigg\rangle 
    \end {array}
  }
  { 
  \Gamma \vdash p_1,\ldots,p_m :P ~~ 
  \langle\Gamma_p,E_p \rangle &&
   \Gamma_p \vdash t : O ~~ \langle E \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
Suppose the patterns on the left hand side in the function defintion are constructors of a data type D.  $C_1$ $\ldots$ $C_m$ are the different constructors of the data type D and $A_1$, $\ldots$, $A_k$ are the union of type variables used in the different constructors of the data type.
\begin{align*} 
\forall A_1,~ \ldots,~A_k.~data~ D ~\to~ A =
 & ~~ C_1 : F_{11},~ \ldots, ~ F_{1a} \to A \\
 & ~~~~ \vdots \qquad\qquad \vdots \qquad\qquad \vdots \\ 
 & ~~ C_m : F_{m1} ,~ \ldots, ~ F_{mn} \to A
\end{align*}
$\alpha$ renaming the different constructs in the data D with fresh variables $A_1^{\prime}$, $\ldots$, $A_k^{\prime}$ gives the following constructs. 
\begin{align*}
 & ~~ D^{\prime} ~~~ = (\Lambda A_1,\ldots,A_k.~ D)~A_1^{\prime},\ldots,A_k^{\prime}\\ 
 & ~~ F_{xy}^\prime~~ = (\Lambda A_1,\ldots,A_k.~F_{xy})~A_1^{\prime},\ldots,A_k^{\prime} 
 ~~~  \{1 \leq x \leq m,~1 \leq y \leq p ~|~ p \in \{a,b,\ldots,n\} \} \\
 \end{align*}

\begin{mdframed} [style=MyFrame,userdefinedwidth=15cm,align=center,
                  frametitle=Typing rule for function defns with constructor patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_2]
  {
    \begin {array}[c]{l}
      \Gvdash
      \fun
        {
          \begin{array}[c]{lcl}
            C_1 ~ x_{11},\ldots,x_{1a} & \to & t_1 \\ 
            \vdots & \vdots & \vdots \\
            C_m ~ x_{m1},\ldots,x_{mn} & \to & t_m
          \end{array}          
        }:T \\~~\\~~\\   
      \hskip 4em \bigg\langle \exists 
                 \begin {array} [c] {l}
                    ~ S_{11},\ldots,S_{1a} \\
                    \qquad \vdots \qquad \qquad . \\ 
                    ~ S_{m1},\ldots,S_{mn} \\ 
                    ~ T_1,\ldots,T_m,O
                 \end {array}  
                  \begin
                    {array}[c]{l} 
                         T = D^\prime ~ \to ~ O,\\
                         T_1 = O,\ldots,T_m = O,\\ 
                         S_{11} = F_{11}^\prime,\ldots,
                         S_{1a} = F_{1a}^\prime, \\
                         \qquad\qquad \vdots \\ 
                         S_{m1} = F_{m1}^\prime,\ldots,
                         S_{mn} = F_{mn}^\prime, \\
                         E_1,\ldots,E_m
                  \end {array}       
          \bigg\rangle 
    \end {array}
  }
  { 
   \begin {array}[c]{lcl}
     \Gamma,x_{11}:S_{11},~\ldots,~x_{1a}:S_{1a} & \vdash &  t_1 : T_1 ~~~ \langle E_1 \rangle \\
     \hskip 6em \vdots \\ 
     \Gamma,x_{m1}:S_{m1},~\ldots,~x_{mn}:S_{mn} & \vdash &  t_m : T_m ~~\langle E_m \rangle
   \end{array}
  }~~\\~~\\
\end{mdframed}
~~\\~~\\
\subsection {Function defintions with an annotated type}
These are the function definitions for which the programmer has annotated the expected type of the function. Once the function is type inferred, an attempt is made to unify the annotated function type with the inferred one. If the two types can be successfully unified, then the inferred type is line with the expectation of the programmer and the annotated type is inserted in the symbol table with the name of the function.
~~\\~~\\ 
The type equations generated for the annotated functions differ slightly from the unannotated ones. In the interest of succinctness, we will describe the equation generation only for the variable patterns case. Equation generation for the constructor pattern case can be easily extrapolated from this.
~~\\~~\\
Let the annotated function be represented as following.
\begin {align*}
annotatedType = \forall~A_1,\ldots,A_k~.fType
\end {align*}
Renaming the variables $A_1$,$\ldots$,$A_k$ with $A_1^\prime$,$\ldots$,$A_{k}^\prime$ yields the following type.
\begin {align*}
annotatedType^\prime &= (\Lambda A_1,\ldots,A_k~.~annotatedType)~
                   A_1^\prime,\ldots,A_k^\prime \\
                &= \forall~A_1^\prime,\ldots,A_k^\prime~.fType^\prime
\end {align*}
\begin{mdframed} [style=MyFrame,userdefinedwidth=18cm,align=center,
                  frametitle=Typing rule for function defns with variable patterns,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm fdefn_1]
  {
    \Gvdash
    \funT
      {
       \forall~A_1^\prime,\ldots,A_n^\prime~.fType^\prime
      } 
      {
        \begin{array}[c]{lcl}
          x_1,\ldots,x_m & \to & t
        \end{array}          
      }:T 
    ~~~ \bigg\langle
             \begin {array} [c] {l}
             \forall ~A_1^\prime,\ldots,A_n^\prime \\ 
             \exists ~T \qquad\qquad~~.~ 
             \end {array} 
                \begin
                  {array}[c]{l} 
                       T = fType^\prime,\\
                        E_{fun} 
                \end {array}       
        \bigg\rangle 
  }
  { 
    \Gamma ~\vdash
    \fun
      {
        \begin{array}[c]{lcl}
          x_1,\ldots,x_m & \to & t
        \end{array}          
      }:T ~~ \langle E_{fun} \rangle
  }~~\\~~\\
\end{mdframed}
~~\\~~\\

% ---------------------------------------------------
% ---------------------- default---------------------
% ---------------------------------------------------
\subsection {default term}
{\sf default} term is used as the catch all branch while using guards with the switch statement. The type of the default term is always Bool. 
~~\\~~\\
\begin{mdframed} [style=MyFrame,userdefinedwidth=9cm,align=center,
                  frametitle=Typing rule for default,frametitlerule=true,
                  frametitlerulewidth = 1pt
                 ]
~~\\~~\\
\infer [\rm default]
  {
   \Gvdash default: T  
    ~~~ \bigg\langle T = Bool 
        \bigg\rangle 
  }
  { 
  }
\end{mdframed}
~~\\~~\\

\end {document}

